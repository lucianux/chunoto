Capítulo 2

Introducción a Android

2.1 Objetivo

El objetivo general del capítulo es la presentación de las características destacables de la plataforma Android.
Este capítulo se divide en 3 partes: primero se empieza con una introducción que abarca algunos datos estadísticos relevantes, una definición, características generales y la evolución; segundo, se presentan características internas del sistema; al final, se presenta el conjunto de herramientas que se usan para el desarrollo y la publicación de aplicaciones.

2.2 Introducción

Android es un ecosistema que esta creciendo constantemente, por ejemplo, cada tanto se le adhiere soporte al sistema para nuevos dispositivos (como la incorporación de los wearables devices), los consumidores compran y activan dispositivos de forma masiva, los usuarios descargan e instalan nuevas aplicaciones con una frecuencia muy alta, también surgen constantemente nuevas versiones de los kits de desarrollo. Se han publicado muchas versiones de Android desde su primer lanzamiento, en cada una se agregaron nuevas características, nuevos componentes gráficos, nuevas funciones y correcciones de bugs. Con lo cual, existe movimiento dentro del ámbito de Android.
Android es más que un sistema operativo, es una pila de software completa (que incluye un sistema operativo, middleware y aplicaciones claves) de código abierto bajo la licencia Apache [ANDDIFF]. Por empezar, yace sobre un kernel basado en Linux y tiene una base sólida proporcionada por el ambiente de Linux (como por ejemplo, las librerías pertenecientes a la comunidad de Linux). Es desarrollado por un consorcio de varias empresas multinacionales lideradas por Google (entre ellas estan Texas Instruments, Nvidia, Samsung Electronics, LG y Intel). Este conglomerado de empresas se lo denomina "Open Handset Alliance" (OHA) y se la creó con la finalidad de desarrollar estándares abiertos para dispositivos móviles, también se presume que se juntaron para frenar el crecimiento de Apple en el ámbito móvil. Además, recibe contribuciones de la comunidad de software libre en el desarrollo y mantenimiento de Android.
Android tiene la capacidad de ejecutar aplicaciones escritas en Java que utilizan la API de Android, dado que tiene una máquina virtual parecida a la de Java. Estas aplicaciones pueden ser descargadas desde múltiples marketplaces. Entre ellos está el marketplace de Google, denominado Google Play, el cual es considerado el marketplace oficial para Android; también hay otros alternativos, como Amazon Appstore. En cuanto a Google Play, es el principal marketplace para vender y distribuir aplicaciones; en el cual los desarrolladores pueden subir sus propias aplicaciones para que los usuarios de dispositivos móviles puedan compararlas, descargarlas e instalarlas; es un mercado abierto que le otorga al desarrollador el control de la forma en que se venden sus productos; dado que permite que las aplicaciones se distribuyan ampliamente, incluyendo a todos los paises disponibles y a todos los dispositivos con Android, o enfocándose en paises específicos y/o dispositivos con atributos específicos. Además, premia con la promoción a los productos que crecen en popularidad, por ejemplo existen rankings que exponen a los mejores productos según una determinada cualidad como la cantidad de ventas [ANDABOU]. La aplicación cliente de Google Play se encuentra preinstalado en la mayoría de los dispositivos con Android.
Las siguientes estadísticas pueden dar una idea de la repercusión del proyecto. Android es la plataforma móvil más popular porque, a la fecha del 20 de Agosto del 2015, tiene una cuota del mercado del 82% [GARTDRO],
	"Android suministra un sistema base a cientos de millones de dispositivos móviles en más de 190 países en todo el mundo." [ANDABOU]
	"Cada día, más de 1 millón de dispositivos móviles con Android son activados a escala mundial. [ANDABOU]
	"Los usuarios de Android descargan mensualmente más de mil millones de aplicaciones mediante Google Play." [ANDABOU]

Según un informe publicado por la empresa de estadísticas basadas en Internet llamada "Statista", en Julio del 2015 el número de aplicaciones disponibles en Google Play llegó a 1,6 millones y es la que lidera el mercado de tiendas online de aplicaciones, le sigue App Store de Apple con 1,5 millones [STATIST]. Según AppBrain, en el mes de Octubre se estima que la cifra llegó a 1737699 aplicaciones en Google Play, también indica que el 12% de esas cantidad corresponden a aplicaciones de baja calidad [APPBRAI].
El desarrollo de Android esta a cargo del proyecto AOSP (Android Open Source Project), el cual se compone de recursos humanos, procesos y código fuente [FAQAND2]: las personas supervisan el proyecto y desarrollan el código fuente actual (el cual puede ser descargado libremente desde el repositorio), los procesos constan de herramientas y procedimientos que se usan para manejar el desarrollo del software. Uno de los objetivos de este proyecto es asegurarse de que el software de Android esté implementado de la forma más amplia y más compatible como sea posible, para el beneficio de todos [FAQAND1]. Lo cual implica que el sistema Android sea portable para soportar una gama de dispositivos.
Con respecto a los esfuerzos para mejorar la portabilidad, Android soporta principalmente la arquitectura ARM, aunque también tiene soporte para la arquitectura x86, un ejemplo concreto es el proyecto Android-x86 [ANDRX86]. Android se lo usa en una variedad de dispositivos tal como smartphones [ANDROPH], notebooks, netbooks, tablets [ANDROTA], autos [ANDROAU], smart TVs [ANDROTV], smartbooks, ebook readers, relojes [ANDROWE], cámaras fotográficas digitales y otros.

2.2.1 Definición

Android es una pila de software open source creada y pensada para una gran variedad de dispositivos. Según el sitio del proyecto AOSP, el propósito principal de Android es:
	"Crear una plataforma de software abierta disponible para los fabricantes (OEMs - Original Equipment Manufacturer), proveedores de telefonía móvil y desarrolladores para hacer realidad sus ideas innovadoras y para introducir un producto en el mundo real con éxito que mejore la experiencia móvil de los usuarios." [ANDOPEN]
	"El resultado es un producto completo, con calidad de producción, con código fuente abierto para la personalización y portabilidad" [ANDOPEN].
De ésto se puede llegar a concluir que uno de los objetivos del sistema operativo Android es que se pueda llegar a instalar en la mayor cantidad de dispositivos posibles, ergo plantea la posibilidad de tener un sistema operativo universal. Para lograrlo, se le brinda al fabricante o al proveedor (o a cualquiera) de hardware la posibilidad de adaptar el software según el ámbito del dispositivo, dado que el código fuente es libre y gratuito.

2.2.2 Hitos históricos en Android

Éstos son algunos de los hitos más relevantes en la historia de Android [WANDHIS] [WIKIOHA] [ANDOPEN]:
En Octubre del 2003, se fundó la empresa Android, Inc. en Palo Alto, California.
En Agosto del 2005, Google adquirió Android Inc.
En Noviembre del 2007, se inauguró la Open Handset Alliance [OHAOVER].
En Noviembre del 2007 se publica una versión beta del kit de desarrollo (SDK) de Android con una licencia Open Source. [WIKIOHA]
En Agosto del 2008, Google anunció la disponibilidad de su marketplace: Android Market (la versión previa a Google Play).
En Octubre del 2008, salió la versión oficial de Android Open Source Project (AOSP).
En Octubre del 2008, salió la versión 1.0 de Android, llamada "Apple Pie".
En Febrero del 2009, salió la versión 1.1 de Android, llamada "Banana Bread".
En Abril del 2009, salió la versión 1.5 de Android, llamada "Cup Cake".
En Septiembre del 2009, salió la versión 1.6 de Android, llamada "Donut".
En Octubre del 2009, salió la versión 2.0 de Android, llamada "Eclair".
En Mayo del 2010, salió la versión 2.2 de Android, llamada "Froyo".
En Diciembre del 2010, salió la versión 2.3 de Android, llamada "Gingerbread".
En Febrero del 2011, salió la versión 3.0 de Android, llamada "Honeycomb".
En Octubre del 2011, salió versión 4.0 de Android, llamada "Ice Cream Sandwich".
En Julio del 2011, salió la versión 4.1 de Android, llamada "Jelly Bean".
En Noviembre del 2012, salió la versión 4.2 de Android, también llamada "Jelly Bean".
En Julio del 2013, salió la versión 4.3 de Android, también llamada "Jelly Bean".
En Octubre del 2013, salió la versión 4.4 de Android, llamada "KitKat".
En Noviembre del 2014, salió la versión 5.0 de Android, llamada "Lollipop".
En Marzo del 2015, salió la versión 5.1 de Android, también llamada "Lollipop".

2.2.3 Características generales

En esta sección se congregan algunas características generales destacables de la plataforma Android:
Desarrollo abierto: el desarrollo de aplicaciones para Android es relativamente sencillo, porque no requiere aprender lenguajes complejos de programación. Todo lo que se necesita es un conocimiento aceptable de Java, el cual es un lenguaje bastante conocido en el ámbito del desarrollo de software; luego se debe descargar, instalar y configurar el kit de desarrollo de Android (en general se lo llama SDK, aunque en Android se lo llama ADK) provisto gratuitamente por Google, el cual se puede descargar gratuitamente; y por último, se necesita un IDE (Integrated Development Environment) para facilitar las tareas habituales de desarrollo de software [ANDWIRE].
Completo: los diseñadores de Android tomaron un enfoque integral cuando desarrollaron la plataforma. Comenzaron con un sistema operativo seguro y terminaron construyendo un framework robusto en el tope de la pila de capas, el cual permite buenas oportunidades de desarrollo de aplicaciones [OHAOVER].
Abierto: la plataforma Android se proporciona a través de licencias open source. Ahora los desarrolladores tienen cierto acceso a las características de los smartphones en el desarrollo de aplicaciones que antes no tenían [ANDWIRE]. Y los fabricantes tienen acceso al código fuente de Android para portarlo a sus nuevos dispositivos [ANDOPEN].
Gratuito: el desarrollo y testing de aplicaciones de Android es gratuito. Es decir, no hay licencias o cánones por el desarrollo en esta plataforma. Ni se requiere pagos por el firmado digital del software desarrollado (en el capítulo 3 se verá qué es una firma y cómo se firma una aplicación). Las aplicaciones de Android pueden ser distribuidas y comercializadas en una variedad de formas (gratuitas o no) [ANDWIRE].

2.2.4 Características técnicas

A grandes rasgos, éstas son las cualidades principales de Android [ANDSECU] [WIKIFEA]:
Framework para las aplicaciones: el framework disponible para las aplicaciones de Android esta diseñado para promover el reuso y el reemplazo de componentes (software) existentes.
Disposiciones del dispositivo: la plataforma es adaptable a diferentes tamaños y disposiciones de pantalla, además de las tradicionales que tienen los smartphones.
Multitarea: el sistema posee soporte multitarea en la ejecución de aplicaciones.
Máquina Virtual: el sistema tiene una máquina virtual llamada "Dalvik Virtual Machine" que está optimizada para ser usada en ambientes embebidos, los cuales tienen restricciones en la memoria, la velocidad del procesador, tiempo de vida de la bateria, etc.
Navegador: el navegador web disponible en Android esta basado en el motor de renderizado open source WebKit, junto con el motor V8 de JavaScript de Chrome. Sin embargo, las versiones más recientes de Android incorporan a Google Chrome como navegador por defecto, el cual no utiliza el motor WebKit.
Gráficos: los gráficos estan integrados en la capa superior, dentro de una librería personalizada de gráficos 2D. Los gráficos 3D están basados en la librería OpenGL ES, las versiones mas populares que circulan en el mercado son 2.0, 3.0 o 3.1 [DASHAND].
Almacenamiento: se usa la librería SQLite, una base de datos relacional liviana que es usada para almacenar y manipular datos en un entorno local.
Mensajería: Está disponible la mensajería por SMS y MMS.
Media: Android soporta los formatos de archivos de imagen, audio y video que comunmente se necesitan. Específicamente, Android soporta los siguientes formatos multimedia: WebM, H.263, H.264, AAC, HE-AAC, MPEG-4 SP, AMR, AMR-WB, MP3, MIDI, Ogg Vorbis, FLAC, WAV, JPEG, PNG, GIF, BMP, WebP.
Conectividad: tiene soporte para varias tecnologías que sirven para conectarse a una red, entre ellas estan: redes de celulares (1G, 2G, 3G y 4G), WiFi, Bluetooth y NFC.
Tethering: Android soporta tethering. Lo que permite que un smartphone con conexión a Internet actúe como intermediario (pasarela) para ofrecer acceso a la red a otros dispositivos; este intermediario realiza las tareas de un router. Antes de la versión 2.2 de Android, esta funcionalidad estaba disponible mediante aplicaciones de terceros o adaptaciones del fabricante.
Ambiente de desarrollo: posee un rico ambiente de desarrollo con un IDE incluido y un emulador de dispositivos para depurar, probar y analizar.
Accesibilidad: Android provee la capacidad de convertir la voz del usuario en texto.
Soporte de múltiples idiomas.
Soporte de hardware adicional: Android puede manejar cámaras (que pueden tomar fotografías o capturar video), pantallas tipo touchscreen, GPS, acelerómetros, giroscopios, etc.
Almacenamiento externo: la mayoría de los dispositivos Android incluyen soporte para tarjetas microSD formateadas con los sistemas de archivos FAT32, ext3 o ext4. Muchas tablets con Android incluyen entradas USB para permitir el uso de dispositivos de almacenamiento de alta capacidad como pendrives y discos duros externos vía USB [ANDROTG].



2.2.5 Android Open Source

(A) Definir qué es Open Source.
(B) Presentar posturas.
(C) Definir una conclusión.

FACTORES A FAVOR Y EN CONTRA de Android que lo hacen software libre o no.

* Hablar de AOSP que tiene una licencia Apache.

La licencia preferible de AOSP es Apache 2.0 (Apache Software License, Version 2.0), pero hay excepciones como en los parches del kernel de Linux que tienen la versión GPLv2 [ANDRLIC].

Según el proyecto AOSP [ANDOPEN], tienen intensiones de que Android sea una plataforma de software abierta. Todo el código fuente que se puede adquirir de Android se lo puede encontrar en el repositorio que provee este proyecto, AOSP es un punto central donde se concentran los esfuerzos de Google por hacer de Android un proyecto Open Source.

Hay ciertas actitudes de Google en su proyecto Android que estan mal vistas por los puristas de la comunidad de software al proclamarse como Open Source, como por ejemplo ...
Code changes are not made available to the public immediately after they are made. Instead, open source releases accompany new version releases. Unfortunately, several times the open source code was not made available at release time. In fact, the source code for Android Honeycomb (3.0) was not made available until the source code for Ice Cream Sandwich (4.0) was released. In turn, the Ice Cream Sandwich source code wasn’t released until almost a month after the official release date. Events like these detract from the spirit of open source software, which goes against two of Android’s stated goals: innovation and openness [ANDHACK].
O SEA...
Google desarrolla muchas veces tecnologías de forma cerrada y privada y luego libera grandes partes de estos códigos. Y esto, es bastante habitual en muchos otros proyectos open source. De hecho es razonable que así sea. [ANDROES]

Otras cosas que NO vuelven a ANDROID en un proyecto Open Source son...
The vast majority of open source projects, for example, have public mailing lists and forums where the main developers can be found interacting with one another, and public source repositories providing access to the main development branch’s tip. No such thing can be found for Android. [EMBANDR]

Debido a ésto, EVIDENTEMENTE ...
Obviously there is a certain amount of discomfort in the open source community with the continued use of the term “open source” in the context of a project whose development model contradicts the standard modus operandi of open source projects, especially given Android’s popularity. The open source community has not historically been well served by projects that have adopted a similar development model. Others fear this development model also makes them vulnerable to potential changes in Google’s business objectives.

A PESAR DE ELLO, ...
Despite its awkward development model from an open source community perspective, it remains that Google’s work on Android is a godsend for a large number of developers. []

---

Como punto de partida se puede analizar las características que debe tener un proyecto Open Source según Open Source Initiative (OSI) [OPENSOU]. Básicamente estas condiciones están relacionadas con los términos de la licencia y con la filosofía del movimiento del software libre.

Como punto de partida se mostrará brevemente cuáles son las características que debería tener un proyecto Open Source, que algunas estan relacionadas con una filosofía y otras con las cualidades de la licencia. En base a éso se evaluará si Android cumple con estas condiciones de acuerdo a varios artículos que exponen los rasgos que tiene Android relativos a si un proyecto merece ser calificado como Open Source. Al final, se presentará una conclusión.

Según la corporación sin ánimo de lucro llamada Open Source Initiative (OSI), la cual promueve el conocimiento y la importancia del software no propietario [ABOUOSI], define una serie de características que algunas son filosóficas y otras estan relacionadas con las cualidades de la licencia de software.

* Hablar de que un proyecto Open Source puede otorgar privilegios de escritura para sus repositorios permitiendo la contribución a ellos.
* Podría seguir viendo lo que dice https://source.android.com/source/faqs.html

Se puede hacer un balance, exponiendo dos posturas: (POSTURA 1) y (POSTURA 2), en una se pueden contar las ventajas y en la otra las desvantajas.
Android es un proyecto que consiste en: un sistema operativo, el middleware y aplicaciones, todas éstas combinan software Open Source y Closed Source (sin acceso al código fuente).

Cualquiera puede ver el código fuente de Android, cualquiera puede hacer un fork de Android, cualquiera lo puede usar en cualquier dispositivo, incluso venderlo; todas estas actividades se pueden realizar de forma directa (sin pedir permiso a ninguna entidad) y sin pagar un canon.

Android es gratis, el usuario final no le debe pagar a los responsables de Android por su uso, como sí pasa con Windows de Microsoft o Mac OS de Apple. Sin embargo, la inversión que hacen todas las empresas del consorcio llamado Open Handset Alliance (OHA) al final la recuperan con la venta de sus productos involucrados con el entorno de Android, ya sea hardware o software.

Google promociona sus productos principales (Google Drive, Gmail, Chrome, Youtube, Google Maps, etc.) en Android con los cuales gana dinero lo cual está mal visto en la comunidad del software libre; no obstante, estos productos pueden ser reemplazados por cualquier otra aplicación, incluso las aplicaciones del sistema se pueden reemplazar. Generalmente se usan las de Google porque son mejores que sus alternativas; por ejemplo, los proveedores de telefonía celular y fabricantes sustituyen algunas aplicaciones por otras, por lo general son peores.

Algo a favor de la apertura de Android es que hay proyectos Open Source basados en Android, como el proyecto llamado Replicant; de hecho, el proyecto Cyanogen se hizo posible por la cantidad de código abierto que contiene Android.

[CONCLUSIÓN]
La conclusión que se pudo extraer es que en un proyecto tan grande como Android, en donde hay muchos participantes, no es estrictamente Open Source. Hay partes como el núcleo, librerías y otros elementos que si son Open Source; en cambio, algunos drivers y partes de código aportadas por fabricantes no lo son [LINADIC]. Vale aclarar que Android no es el único sistema operativo móvil que forma parte de un proyecto Open Source; también se puede afirmar que la mayor parte de Android es Open Source.

[LINADIC] [http://www.linuxadictos.com/realmente-android-es-un-sistema-open-source.html]
[ABOUOSI] [https://opensource.org/about]
[OPENSOU] [https://opensource.org/osd-annotated]
[ANDRLIC] [https://source.android.com/source/licenses.html]

[VOLKAND] [https://volkanrivera.com/esp/2010/10/es-android-open-source/]
[ANDROES] [http://www.android.es/un-poco-de-luz-sobre-si-android-es-open-source-y-gratis.html]


2.3 Arquitectura de Android

Desde el punto de vista de la arquitectura, el sistema operativo Android esta basado en una pila de capas. Seguidamente, se comentarán los beneficios de trabajar de esta forma, luego se describirá cada capa del sistema Android.
Ésta son algunos de los beneficios de trabajar con capas [STACKLA]:
- Para cada capa (excepto la capa del fondo), las aplicaciones de la capa superior serán capaces de reusar la funcionalidad (servicios) expuesta por la capa inferior.
- El mantenimiento del proyecto es más fácil por el bajo acoplamiento entre las capas.
- Facilita la adición de más funcionalidad al proyecto.
- Las capas generan un ambiente más apto para el desarrollo de pruebas.
- La distribución del software en capas hace que sea mucho más fácil el diseño e implementación del proyecto.

[ Imagen "Android Architecture.png" ]

2.3.1 Kernel de Linux

[ https://www.quora.com/What-are-the-major-changes-that-Android-made-to-the-Linux-kernel ]
[ http://www.howtogeek.com/189036/android-is-based-on-linux-but-what-does-that-mean/ ]

En la capa mas interna de Android se encuentra el kernel, la parte central del sistema operativo. El kernel que usa Android es una versión modificada del kernel de Linux, este último proporciona una base sólida que se aprovecha para construir la base de este sistema operativo móvil. Para ello se realizaron adecuaciones especiales a algunas de sus partes principalmente para que pueda soportar la plataforma móvil, a parte de corregir bugs, mejorar el software y agregar nuevas funcionalidades (se adhirieron funciones de depuración, por ejemplo) [ANDDIFF].
Linux es un sistema operativo basado en Unix que fue diseñado para suministrar un sistema operativo gratuito o de muy bajo costo para los usuarios de computadoras personales, está a la altura de los tradicionales y costosos sistemas Unix [ANDDIFF]. Linux tiene una reputación de ser un sistema muy eficiente y con un buen rendimiento. El kernel de Linux fue desarrollado por Linus Torvalds en la Universidad de Helsinki en Finlandia. Para terminar el sistema operativo, necesitó de la colaboración de otros desarrolladores que juntos usaron aplicaciones desarrolladas por los miembros de la Fundación de Software Libre para el Proyecto GNU.
Linux fue desarrollado para desktops, laptops y servers; mientras que Android fue desarrollado para dispositivos móviles [ANDDIFF]. Para poder adaptar el kernel de Linux al entorno de Android se tuvieron en cuenta algunas cualidades particulares del entorno [ANDDIFF]: el tamaño pequeño y la practicidad de los dispositivos, la conectividad continua (frecuente y múltiple), la diversidad de dispositivos, su plataforma abierta, la memoria limitada, etc.
En Android se toman partes del kernel de Linux como base de apoyo como el modelo de drivers [SOUANDR], los drivers existentes, la Capa de Abstracción del Hardware (Hardware Abstraction Layer - HAL) [SOUANDR], el soporte de red, la administración de procesos y memoria, entre otros [SURVLIN]. Sin embargo, hay algunas características de Linux que se descartaron, dado que Android no tiene todas las características de una distribución de Linux tradicional; como por ejemplo, se descartó el sistema de ventanas X, como también se descartaron todas las utilidades GNU que generalmente se encuentran en la ubicación "/bin"; además, muchos de los archivos de configuración ya no están (como el archivo que se ubica en "/etc/passwd") [ANDSECU].
Una parte importante que se aprovecha de Linux es la Capa de Abstracción del Hardware (Hardware Abstraction Layer - HAL), la cual define una interfase estándar para que la respeten los proveedores de hardware en la implementación de drivers de bajo nivel (permiten una comunicación entre el hardware y el sistema operativo); gracias a esta estandarización, Android es independiente de las implementaciones de estos drivers [SOUANDR], lo que propicia la portabilidad del sistema operativo a una gran variedad de dispositivos.
En términos generales, las siguientes definiciones pueden esclarecer lo que es HAL:
	"la Capa de Abstracción del Hardware aísla el sistema operativo de las diferencias de hardware específicas de la plataforma" [WILLSTA]
	"El HAL permite al software de las capas superiores detectar y usar el hardware a través de una API simple y portable, sin importar el hardware sobre el que se estuviese ejecutando." [OMETERH]
Este modelo heredado de Linux facilita el trabajo a los proveedores de hardware cuando desarrollan drivers porque proporciona un procedimiento estándar bien probado y documentado. De hecho, para muchos dispositivos, los drivers del hardware ya estan incorporados dentro del kernel y estan disponibles libremente; hay una comunidad activa de desarrolladores que mantienen los drivers del kernel de Linux [ANDSECU]; de esta forma el kernel de Linux proporciona un modelo robusto de drivers para dispositivos.

Este proceso de adaptación se logró con la ayuda del proyecto "Android Mainlining Project" [ANSECIN], la cual es una wiki que expone y preserva información acerca del desarrollo y uso de las bases de Linux sobre Android; uno de los objetivos que persigue es:
	"permitir a un desarrollador usar la última versión del kernel de Linux para correrlo en un sistema Android, sin la necesidad de aplicar parches" [ELINAMP]
Gracias a las contribuciones que aportó este proyecto, se puede correr un sistema Android con un kernel de Linux reciente sin modificaciones de terceros (un kernel descargado de kernel.org), sin embargo este proceso requiere cierto esfuerzo en la adaptación del software. Para lograr esta adaptación con éxito, básicamente se tomó el código fuente del kernel original y se lo modificó para que se pueda ejecutar en un ambiente embebido, para ello el equipo de desarrollo de Android ha creado, y sigue manteniendo, un fork* del kernel de Linux especial para ambientes embebidos [ANDSECU], ésto forma parte del proyecto AOSP. Entonces, las mejoras y actualizaciones que se van incorporando en el fork*, luego se irán incorporando a las futuras versiones de Android, a medida que se vayan publicando. De esta forma los usuarios obtienen lo mejor que Linux tiene para ofrecer. En la tabla 1 se muestran algunas versiones de Android con los kernels de Linux en que se basaron.
Con respecto al proyecto "Android Mainlining Project", es un proyecto antiguo que tuvo su momento, dado que algunas páginas de esta wiki tuvieron su última modificación en el año 2011. Se puede decir que este proyecto impulsó la documentación de la implementación de Android que en ese tiempo no era un tema popular, por la falta de conocimientos y fuentes de información; luego, pasado cierto tiempo, se fueron escribiendo libros, blogs y sitios webs que mejoraron y propagaron la documentación de este tipo de temas acerca de Android, actividad que dejó obsoleta a esta wiki, aunque sirvió como una base para introducirse en este tema.
[Tabla 1 : correspondencia entre las versiones de Android y los kernels de Linux ]
Android Cupcake 1.5              Linux Kernel 2.6.27
Android Donut 1.6                Linux Kernel 2.6.29
Android Éclair 2.0/2.1           Linux Kernel 2.6.29
Android Froyo 2.2                Linux Kernel 2.6.32
Android Gingerbread 2.3.x        Linux Kernel 2.6.35
Android Honeycomb 3.x            Linux Kernel 2.6.36
Android Icecream Sandwich 4.x    Linux Kernel 3.0.1

A parte de reutilizar partes de Linux, hay ciertas características particulares de Android que se agregaron al kernel de Linux original, a éstas se las llaman "Androidism" [KERFEAT]. A continuación, se presentarán algunas características que no están en el kernel original, luego se presentará un rasgo distintivo de Android, Binder que tiene un rol protagónico en el sistema.
-Paranoid networking: usualmente en Linux, todos los procesos tienen permitido la creación de sockets y la interacción con la red; pero en Android, el acceso a estas operaciones debe ser más controlado. Por eso se agregó un mecanismo al kernel para controlar el acceso a estas acciones en la red en base al grupo al que pertenece el proceso [EMBANDR]. Por ejemplo, si un proceso quiere acceder a la red, el sistema corrobora si es miembro del grupo "AID_INET" (o "AID_NET_BT" para el caso del Bluetooth); si lo es, le permite el acceso, de otro modo el acceso le es denegado. De hecho, los permisos para los archivos y dispositivos son establecidos por el proceso Init [PARANDR] [ANDPARA].
-Ashmem (Anonymous Shared Memory): es un administrador de memoria compartida basado en archivos [ANDHACK]. Es muy adecuado para ambientes con poca memoria porque esta diseñado para reducir automáticamente las caches de memoria y recuperar las regiones de memoria cuando la memoria disponible de todo el sistema se vuelva baja [EMBANDR]. Ashmem tiene la capacidad de utilizar el recuento de referencias para destruir regiones de memoria, cuando todos los procesos que se refieren a ellas han salido; esta característica es aprovechada por Binder. También tiene la capacidad de reducir regiones mapeadas si el sistema necesita memoria. Cuando se realiza esta operación, ashmem considera las regiones marcadas como "unpinning" y "pinning", que son aquellas que se puede ejecutar la reducción y aquellas que no, respectivamente.
-Pmem: este driver es obsoleto [EMBANDR], la función de este driver era de compartir grandes bloques de memoria que estan dispuestos contiguamente.
-Bluetooth: Google realizó cambios en la pila de comunicaciones vía Bluetooth, son cambios que arreglan errores relacionados a dispositivos Bluetooth específicos; se agregaron funciones de depuración en Bluetooth y funciones de control de acceso [ANDDIFF].
-Soporte para la unidad de almacenamiento: en la plataforma PC se guardan los archivos en discos (con todas sus variantes), en cambio los dispositivos móviles guardan los archivos en chips de memoria flash de estado sólido. Un tipo de memoria flash que se usa en el ámbito móvil es la memoria llamada "NAND", tiene 2 cualidades para resaltar: son de alta densidad y de bajo costo [ANDDIFF]. Existe un proyecto que provee una interfase de alto rendimiento entre el kernel de Linux y los dispositivos con memorias flash del tipo NAND, este proyecto se llama "YAFFS" y se originó antes que Android; este proyecto ya publicó su segunda versión y se incorporó al kernel de Android, dado que en las primeras versiones de Android no formaba parte del kernel de Linux.
-Low Memory Killer: es un driver que elimina a los procesos activos que alojan componentes que no han sido usados por un largo tiempo y no tienen una prioridad alta. Está basado en el driver que cumplía la misma función en el kernel original, llamado "Out-of-memory Killer" (OOM Killer) [EMBANDR]. Como Android está pensado para ambientes con baja memoria, es crucial el comportamiento del sistema cuando se queda sin memoria, se agregó un driver al kernel original llamado "low-memory killer". El driver original eliminaba procesos solo cuando el sistema se quedaba sin memoria, el de Android permite eliminar procesos cuando se alcance cierto umbral, hay diferentes umbrales que disparan distintas alertas asociados a distintas categorías de procesos de acuerdo a los componentes asociados; es decir, estos umbrales son como perfiles que corresponden a distintas situaciones de baja memoria. Una posible situación hipotética podría ser la siguiente [LWNOOMK]: cuando se alcanza el primer umbral, los procesos en background serán notificados del problema para que sólo guarden sus estados; cuando se alcanza el segundo umbral, es decir, hay una mayor tensión en el sitema por falta de memoria, el dirver procede a matar los procesos en background que no son críticos de los cuales se sabe que han sido guardados cuando se llegó al umbral anterior; finalmente, si la situación es muy difícil, se aplica lo anterior con los procesos que corren en foreground.

-Logger: {vacío}

-Wake Locks: {vacío}

-Alarm: {vacío}

-RAM Console y Log Device: {vacío}

2.3.1.1 Binder

["A Survey of Android Security Threats and Defenses"] [http://isyou.info/jowua/papers/jowua-v6n3-1.pdf]

Una de las ideas que Android heredó de Linux es que los datos que pertenecen a cada proceso estan aislados porque los procesos tienen espacios de direcciones separados. Ésto evita un acceso directo a los datos entre distintos procesos, lo que puede llegar a generar inseguridad e inestabilidad al sistema. Sin embargo, existen casos en que se necesita lograr una comunicación entre procesos; para ello se utiliza un mecanismo IPC ("Inter-Process Communication"), el cual asiste en la divulgación de uno o varios servicios que un proceso ofrece a otros procesos, y así estos procesos pueden descubrir estos servicios; además permite la interacción entre los servicios y el resto de los procesos.
Dado que la implementación de IPC que viene con el kernel de Linux original no es eficiente para entornos embebidos, entonces se decidió tomar las bases de un viejo proyecto discontinuado llamado OpenBinder (soporta varias plataformas) para reimplementarlo. O sea, su implementación fue reescrita y sus ideas principales se mantuvieron [TESBIND], el proyecto nuevo pasó a llamarse Binder. Binder esta pensado para correr en sistemas embebidos, con él se busca disminuir la sobrecarga, aumentar el rendimiento y mejorar la seguridad. Por otro lado, Binder cumple más funciones que un IPC convencional, entre ellas se puede mencionar la administración de memoria y de hilos; sin embargo, la idea de Binder es que estas funciones le sean transparentes al desarrollador de sistemas de bajo nivel, para aclarar este tema se acude a la siguiente cita:
	"A pesar de que el mecanismo RPC que subyace es muy complicado, el framework Binder empaqueta todo y expone APIs simples de usar para hacer que todo el mecanismo de comunicación entre procesos parezca sencillo" [CODETHE].

Binder suministra una serie de abstracciones y mecanismos que facilitan el desarrollo que se realizan en las capas superiores, o sea que es un framework de bajo nivel. Principalmente permite registrar, descubrir e instanciar componentes; también provee la definición de un modelo de objeto (o componente) genérico, un mecanismo estándar para describir interfaces de objetos (usando AIDL, luego se explicará); permite que las instancias de los componentes vivan en distintos procesos, de esta forma se ocupan de los detalles de IPC cuando interactúan procesos [PALBIND]. Según uno de sus creadores, Dianne Hackborn, sostiene que
	"Binder es usado para casi todo lo que ocurre a través de los procesos en la plataforma central" [DIANNEH].

A grandes rasgos, Binder se divide en tres partes [BLOGCUB]: RPC, IPC y driver; a continuación se las expondrán.
Una parte de Binder corresponde al mecanismo RPC (Remote Procedure Call), el cual se usa para realizar la comunicación entre procesos. Se aplica entre un proceso servidor y un proceso cliente, en donde básicamente el proceso cliente puede ejecutar métodos remotos en el proceso servidor como si se estuviesen ejecutando localmente [TESBIND]. En el caso de Binder, los procesos corren sobre un único dispositivo, no soporta RPC a través de la red [ANSECIN].
Otra parte de Binder corresponde al mecanismo IPC (cuando 2 procesos quieren comunicarse), el cual sigue la siguiente secuencia de pasos básica [CODETHE]: en el momento en que un proceso cliente hace una llamada a un proceso servidor (que tiene servicios para ofrecer), le pasa un bloque de datos; para eso, el cliente llama a una función especial para pasarle el bloque de datos, se la llamará "transact()", luego el servidor recibirá una invocación a una función que se la llamará "onTransact()"; la llamada a "transact()" bloquea al hilo del cliente por defecto (mediante cierta configuración se la puede volver en una llamada no bloqueante) hasta que la invocación al método "onTransact()" termina de ejecutarse.
Finalmente, Binder consta de un driver que contiene la implementación de Binder. El driver esta dentro del espacio de direcciones del kernel, ésto es debido a que los procesos no pueden invocar operaciones de escritura o lectura de forma directa sobre otros procesos y el kernel si puede hacerlo. Se puede acceder a este driver por una interfase que se encuentra ubicada en el dispositivo "/dev/binder" [ANSECIN], la cual ofrece una API sencilla basada en las funciones conocidas y heredadas del kernel original: open, release, poll, mmap, flush y ioctl [BINDGAR].

Los clientes y los servicios no conocen nada del protocolo Binder, entonces usan patrones de diseño para que el mecanismo interno de Binder sea transparente: el cliente usa un patrón llamado "proxy" y el servidor usa otro llamado "stub" [CODETHE]. El componente Proxy emula al proceso servidor; recibe invocaciones a sus métodos en lenguajes de alto nivel (Java o C++), los convierte en paquetes de datos para enviarlos al driver de Binder y bloquea el flujo de ejecución del cliente. En el lado del proceso servidor, el componente Stub escucha al driver, desenvuelve paquetes de datos (al recibir pedidos del cliente) convirtiéndolos en tipos de datos que el servidor pueda entender.
{ GRÁFICO CON STUB y PROXY }
Este par de componentes se autogeneran a partir de una especificación simple escrita en el lenguaje AIDL [SLIBIND]. AIDL (Android Interface Definition Language) se compone de un lenguaje específico de Android para definir interfases de servicios basadas en Binder; y por otro lado, se compone de una herramienta que forma parte del entorno de desarrollo de Android, que sirve para generar un archivo Java (una interfase que el servidor debe implementar y que los clientes van a usar) a partir de un archivo escrito en el lenguaje AIDL, es como si fuese un contrato entre los clientes y el servidor [AIDLDEV]. AIDL genera las capas de software (que utilizan abstracciones como stubs y proxies) que son muy tediosas de desarrollar de forma manual porque forman parte de los detalles del mecanismo de Binder; de hecho, las operaciones de bajo nivel y las estructuras de datos del mecanismo interno de Binder son abstraídas por la librería libbinder (en la capa nativa), ésta es utilizada por los clientes y servicios [BINDGAR]. Esta herramienta, por lo general es usada en el ámbito del desarrollo de sistemas a nivel de espacio de usuario.
Por último, cabe destacara que la infraestructura que provee Binder es importante y notable, porque es utilizada en muchos Servicios del Sistema (dentro de la capa superior), como el servicio de notificaciones ("Notification Manager"), el servicio de telefonía ("Telephony Manager"), el servicio de la batería ("Battery Manager"), el servicio de Wi-Fi ("Wifi Manager"), entre muchos otros [CODETHE].

2.3.1.2 Wakelocks

Para administrar la energía, los Sistemas Android tienen Power Managemente PROPIO, los Sistemas Linux usan los conocidos APM, ACPI [ANDDIFF].
[...]

2.3.2 Espacio de usuario nativo

La capa correspondiente al espacio de usuario nativo ("native userspace") provee la funcionalidad mínima y toma los principios de Linux; en esta capa se ubican los componentes ejecutables que corren fuera de la máquina virtual de Dalvik y forman un sistema operativo base. Esta capa consiste de librerías y demonios nativos que fueron escritos en C o C++, los cuales estan optimizados para correr en un ambiente de hardware específico (consideran la arquitectura de la CPU, por ejemplo); en contraste están las aplicaciones y el framework de Android (en la capa superior) que estan escritos en Java y tienen un nivel de abstracción alto. En la capa del espacio de usuario nativo también se encuentran el singular proceso Init y el HAL (Hardware Abstraction Layer) de Linux. Generalmente, estos componentes se inician de forma automática o a demanda del proceso Init (que se basa en archivos de configuración). Estos binarios nativos también estan disponibles para ser invocados desde la línea de comandos cuando el desarrollador acceda por shell al dispositivo (mediante el comando adb, el cual se verá mas adelante). Los componentes de esta capa suelen tener acceso directo a la raíz del filesystem y a las librerías nativas incluidas en el sistema. Sus capacidades estan restringidas por los permisos concedidos por el filesystem y por la combinación UID / GID. Como sucede con el kernel, el espacio de usuario nativo de Android no es igual que el de Linux.

2.3.2.1 Librerías

Android incluye un conjunto de librerías nativas muy útiles que son usadas por diferentes componentes en distintas capas superiores (como la máquina virtual de Dalvik, servicios del sistema, aplicaciones). Los desarrolladores de aplicaciones usan estas librerías mediante el Framework de aplicaciones de Android, usando el lenguaje de programación Java. Sin embargo, cualquier aplicación puede saltear este intermediario, accediendo a alguna de estas librerías compartidas y nativas empleando invocaciones a JNI (Java Native Interface) [ANDSECU]. Dado que las librerías pertenecientes a esta capa son desarrolladas en código nativo (C / C++), son propensas a las vulnerabilidades de corrupción de memoria [ANDHACK]. Muchas de estas librerías nativas pertenecen a proyectos open source y son usadas en entornos Linux [ANDHACK]. Por ejemplo, el proyecto "SQLite" provee funcionalidad para manejar bases de datos locales, el proyecto "WebKit" provee un motor de navedor web embebible, el proyecto "FreeType" cumple funciones de renderizado de imágenes vectoriales de las tipografías a mapas de bits [FREETYP]. Sin embargo, no todas las librerías vienen de proyectos externos y se pueden incorporar sin muchas modificaciones, una excepción es la librería llamada "Bionic", que es una versión más reducida que la librería libc de Linux (librería del lenguaje C del sistema) y optimizada para plataformas embebidas [ANDSECU], así como también existen varias librerías creadas específicamente para Android dentro del proyecto AOSP.

Entre las librerías nativas (tanto internas como externas a AOSP) se pueden mencionar las siguientes:
- libexif (externa): Librería que maneja el formato EXIF para las imágenes.
- libexpat (externa): Librería que realiza las tareas de un parser de XML, proviene de un proyecto de software libre.
- libaudioalsa/libtinyalsa (externa): Librería de audio que se usa en Linux, llamada "ALSA".
- libbluetooth (externa): Librería para la interfase Bluetooth llamada "BlueZ", comunmente usada en Linux.
- libdvm (interno): Librería de la máquina virtual de Dalvik, es propia de Android [EMBANDR].
- liblog (interno): Librería para generar logs [EMBANDR].
- libbinder (interno): Librería de Binder [EMBANDR].
- libui (interno): Librería que contiene funcionalidades de bajo nivel relacionadas a la interfase de usuario, como la utilización del búfer de gráficos [EMBANDR].

Éstas son sólo algunas librerías del stock que incorpora Android. Para tener una idea, un dispositivo que corre Android 4.3 contiene más de 200 librerías compartidas [ANDHACK].
También se puede realizar otra clasificación de las librerías: estan aquellas que son específicas del fabricante y aquellas que no lo son. Las primeras proveen soporte para el hardware único a un modelo de dispositivo, estan ubicadas en el directorio /vendor/lib (o /system/vendor/lib/), éstas incluyen soporte de bajo nivel para los dispositivos gráficos, transceptores GPS o radios de celular. Las segundas, no son específicas del fabricante, estan ubicadas en /system/lib y típicamente incluyen proyectos externos. [ANDHACK].

2.3.2.2 Demonios

Los demonios en Android son como los de Linux, son procesos que corren en background. En Android, algunos demonios principales se inician durante el arranque del sistema, el proceso Init los arranca en esta etapa inicial y siguen corriendo mientras esté encendido el sistema. Otros demonios se inician bajo demanda y dependen de cierta configuración, como el demonio adbd que se usa para conectar un dispositivo externo mediante la línea de comandos [EMBANDR]. Algunos de los demonios más importantes son [EMBANDR]: Zygote (el proceso Zygote es responsable de estimular la cache del sistema y arrancar el Servidor del Sistema), adb, vold (maneja el montaje y el formateo de unidades e imagenes montadas), rild (es un mediador de todas las comunicaciones entre el módulo de Android del Servicio del Teléfono y el procesador de banda base), system_server (corresponde al demonio del Servidor del Sistema de Android: contiene la gran mayoría de los servicios del sistema que corren en Android), etc.

2.3.2.3 ADB

Android Debugging Bridge es una aplicación cliente-servidor que permite la comunicación con un emulador o un dispostivo. Consta de 3 componentes: el demonio ADB (ubicado en /sbin/adbd), el cual corre sobre el dispositivo o emulador; el servicio, que corre sobre el entorno de desarrollo (una PC); y las aplicaciones cliente (por ejemplo, adb o ddms), que se utilizan para comunicarse con el demonio a través del servicio. ADB permite ejecutar comandos interactivos sobre el emulador o el dispositivo, como instalar aplicaciones (mediante archivos .apk), transferir archivos o ingresar comandos a una shell (a través de la shell de adb) [ANDSECU].

{ gráfico esclarecedor de ADB }
{ se podría mejorar la explicación de ADB }

2.3.2.4 Zygote

Como generalmente sucede en los sistemas basados en Linux, en el momento del arranque del sistema, un bootloader carga el kernel e inicia al proceso Init. El proceso Init inicia todos los otros procesos y origina los demonios, cuando termina este proceso, inicia un demonio importante llamado "Zygote". Éste inicia la primer Máquina Virtual de Dalvik (DVM - Dalvik Virtual Machine) y precarga todas las librerías del core usadas por las aplicaciones y el framework de Android [ANDSECU]. Luego, se queda a la espera de nuevas solicitudes para crear nuevas Máquinas Virtuales de Dalvik.
Zygote recibe un pedido para iniciar una nueva Máquina Virtual de Dalvik por cada aplicación iniciada. Cuando Zygote recibe un pedido, aplica la operación fork a él mismo e inicia nuevos procesos que heredan de la Máquina Virtual de Dalvik previamente inicializada. En el caso de Android, la construcción de una Máquina Virtual de Dalvik nueva no provoca una disminución en el rendimiento, dado que las librerías compartidas no se copian a menos que la aplicación realice cambios y modificaciones a estas librerías [ANDSECU]; esta optimización evita tener que repetir el proceso costoso de cargar el Framework de Android y sus dependencias al iniciar nuevos procesos Dalvik (incluyendo aplicaciones); en consecuencia, las librerías del core, las clases del core y sus estructuras de heap correspondientes son compartidas entre las instancias de las DVMs.
Cuando Zygote es iniciado por Init, se copia a sí mismo y arranca un proceso llamado "system_server". Luego, este proceso arranca todos los servicios del core de Android, como por ejemplo, uno llamado "Activity Manager". Una vez que todos los servicios del core hayan iniciado, la plataforma esta lista para lanzar aplicaciones a demanda del usuario. Recordemos que cada aplicación que se arranca, genera un fork de Zygote y la creación una nueva Máquina Virtual de Dalvik.

2.3.2.5 Filesystem

El filesystem tiene un papel preponderante en el espacio de usuario nativo, similar a lo que sucede en el entorno Linux. Sin embargo, el filesystem de Android difiere del que tiene Linux, dado que Android no se adhiere al estándar FHS (Filesystem Hierarchy Standard). Android utiliza la raíz del filesystem para guardar aplicaciones, librerías y datos; los dos directorios principales en donde trabaja Android son /system y /data, los cuales no estan incorporados en el estándar FHS [EMBANDR].
La ubicación /system es el directorio que se usa principalmente para almacenar componentes inmutables generados por la compilación del AOSP. Estos componentes incluyen a binarios nativos, librerías nativas, paquetes del framework y aplicaciones que vienen por defecto. Usualmente es montado en modo de sólo lectura desde una imagen separada del filesystem raíz.
La ubicación /data es el directorio principal para guardar datos y aplicaciones que cambian con el correr del tiempo. Esto incluye datos generados y almacenados por las aplicaciones instaladas por el usuario, junto con los datos generados por los componentes de Android en tiempo de ejecución. Por lo general, al igual que /system, también es montada desde una imagen separada del filesystem raíz, aunque en el modo de lectura-escritura.
Android también incluye muchos directorios comunmente encontrados en cualquier sistema Linux, como /dev, /proc, /sys, /sbin, /root, /mnt y /etc. Por lo general, estos directorios se los trata como sucede en Linux, a pesar de que ellos tienen menos elementos que los de Linux, como es el caso de /sbin y /etc, en algunos casos estan vacíos, como /root.

2.3.2.6 Init

Como sucede en Linux, Init es el primer proceso que es iniciado por el kernel, en el espacio de usuario. El proceso Init inicializa el ambiente del espacio de usuario ejecutando una serie de comandos: inicia servicios y demonios, Init está a la espectativa ante la ocurrencia de eventos para ejecutar comandos o acciones (como por ejemplo, el montaje de un filesystem). Una diferencia con la versión de Linux, es que en vez de ejecutar scripts de shell basados en run-levels definidos en /etc/init.d, Android ejecuta comandos basados en directivas configuradas en /init.rc.

2.3.3 Máquina Virtual de Dalvik

Las aplicaciones Android se escriben en el lenguaje de programación Java, son compiladas a archivos con la extensión "class" de Java y seguidamente estos últimos se compilan a la extensión "dex" para que se puedan ejecutar en la máquina virtual de Dalvik para su distribución, estos compiladores forman parte del kit de desarrollo de Android. Luego el usuario recibe la aplicación y la instala en su dispositivo, para que finalmente proceda a ejecutarla. El archivo con el formato .dex es ejecutado en una Máquina Virtual de Dalvik, la cual es prácticamente como una Máquina Virtual de Java con una implementación distinta [ANDSECU]. O sea, Dalvik le permite a Android correr los bytecodes generados a partir de las aplicaciones escritas en Java; además, Dalvik proporciona los hooks y el entorno necesario para relacionarse con el resto del sistema, incluyendo librerías nativas y el resto del espacio de usuario nativo.
Los entornos Android y Java tienen sus diferencias. En Java, el ambiente de desarrollo esta conformado por 3 partes: el compilador Java, el intérprete de bytecodes de Java (la Máquina Virtual de Java) y las librerías de Java que comunmente se usan en el desarrollado de aplicaciones Java. Usualmente los desarrolladores obtienen todo esto por el conjunto de desarrollo de Java (Java Developmente Kit - JDK) que se descarga del sitio de Oracle de forma gratuita. En Android, el ambiente se basa en el JDK para que el desarrollador pueda compilar aplicaciones escritas en Java; sin embargo, no utiliza ni la JVM, ni las librerías que se encuentran en el JDK [EMBANDR]. En lugar de usar la JVM, se usa la máquina virtual de Dalvik; y en lugar de usar las librerías del JDK, se usa la implementación open source de estas librerías provistas por el proyecto Apache Harmony.
La Máquina Virtual de Dalvik esta diseñada específicamente para afrontar las limitaciones impuestas en los sistemas embebidos, tal como la cantidad de memoria, la velocidad del procesador, ausencia del espacio de intercambio (como la partición swap en los sistemas Linux), fuente de alimentación limitado (batería). Por lo tanto, el diseño de la máquina virtual de Dalvik tiene en cuenta la velocidad y eficiencia, cuestión que lo diferencia de la Máquina Virtual de Java [ANDHACK][EMBANDR]. Además, para afrontar las restricciones de este tipo de ambientes se aplica otra optimización: los archivos DEX se optimizan antes de ser interpretados por la máquina virtual de Dalvik. La salida de este proceso de optimización es un archivo DEX optimizado (ODEX). Cabe señalar que los archivos ODEX no son portables a través de las diferentes actualizaciones de la Máquina Virtual de Dalvik o entre dispositivos; generalmente ésto ocurre una sola vez, cuando se inicia la aplicación por primera vez [ANDHACK].
Actualmente, los dispositivos con Android cuentan con Android Runtime, el cual sustituye a la máquina virtual de Dalvik por cuestiones de rendimiento [ARTANDR].
	"La diferencia fundamental entre Dalvik y ART es cuándo hacen esta traducción o compilación. Dalvik utiliza lo que se llama compilación “justo a tiempo” (just-in-time, o JIT), mientras que ART utiliza compilación previa (ahead-of-time, o AOT)." [ARTANDR]
	"Con el compilador JIT de Dalvik, cada que iniciamos una aplicación, la máquina virtual dinámicamente traduce una parte del bytecode DEX a código máquina. Conforme continúa la ejecución de la aplicación, se compila más bytecode y se almacena en memoria cache. Es por ello que se dice que la aplicación está siendo compilada “justo a tiempo” conforme la usamos. En el caso de ART, las aplicaciones se compilan desde que se instalan en el dispositivo, y ya se deja instalado el código máquina listo para ejecutarse y sin necesidad de mayor compilación." [ARTANDR]

2.3.4 Bibliotecas del Framework de Android

El resultado de la unión entre las aplicaciones y el runtime es el Framework de Android, el cual ofrece herramientas para los desarrolladores (clases y packages) basados en abstracciones que realizan tareas comunes de desarrollo, el desarrollador usa y vuelve a usar estas herramientas, las cuales le permite trabajar con mayor rapidez, concentrándose en el problema. Dentro de las tareas que ya estan resueltas y son transparentes al desarrollador se puede mencionar: la administración de elementos de la interfaz gráfica a bajo nivel, el acceso a los almacenes de datos compartidos y los detalles de la transmisión de mensajes entre aplicaciones. Estas partes de código que no son específicas de una aplicación (sino que se reutilizan en varias aplicaciones) se sigue ejecutando dentro del dominio de la Máquina Virtual de Dalvik [ANDHACK].
Los packages comunes pertenecientes al Framework de Android son aquellos que estan dentro del namespace "android.*", tal como "android.content" o "android.telephony". Android también provee muchas clases estándar a Java (que están en los namespaces "java.*" y "javax.*"), como también packages adicionales de terceros, como por ejemplo la librería "Apache HTTP Client". En esta capa de software también se incluyen varios servicios inherentes al sistema, usados para manejar y facilitar mucha de la funcionalidad provista por estas clases y packages, a estos servicios se los llaman "Managers" y son iniciados por system_server después de la inicialización del sistema [ANDHACK]. Estos Managers pueden ser accedidos mediante clases fachada (muestra una interfase simple con las funciones más importantes); típicamente, cada manager es respaldado por un correspondiente servicio del sistema; por ejemplo, "BluetoothManager" es una fachada para el servicio llamado "BluetoothManagerService" [ANSECIN].
Estos son algunos managers:
- Activity Manager: administra el ciclo de vida de un activity (su definición se encuentra más abajo) en una aplicación y en varios componentes dentro de una aplicación. Cuando una aplicación pide iniciar un activity, por ejemplo por el mensaje "startActivity()", es el Activity Manager el que provee este servicio [ANDSECU].
- Resource Manager: provee acceso a los recursos como strings, gráficos, archivos que definen el diseño de la interfase gráfica, etc. [ANDSECU].
- Notification Manager: maneja notificaciones de eventos como la reproducción de sonidos, vibraciones, el destello del LED, exhibición de íconos en la barra de estado, etc. [ANDHACK]
- Package Manager: junto con el demonio de administración de paquetes (installd), tiene la responsabilidad de instalar aplicaciones en el sistema y mantener información acerca las aplicaciones instaladas y sus componentes [ANDSECU].
- Telephony Manager: administra las tareas y la información relacionados con los servicios de telefonía, estado del radio, la red de telefonía celular, etc. [ANDHACK]
- Views: provee un conjunto abundante de vistas que una aplicación puede usar para mostrar información [ANDSECU].

2.3.5 Aplicaciones del sistema y aplicaciones instaladas por el usuario

Los usuarios nunca ven el subsistema de Linux, ni van a interactuar con el espacio de usuario nativo, ellos van a ver la capa superior donde está la interfase gráfica del sistema operativo que muestra la funcionalidad básica y las aplicaciones que extienden esta funcionalidad. Android viene con un rico conjunto de aplicaciones pre-instaladas, incluyendo un browser, un programa que gestiona mensajes SMSs, un calendario, un cliente de emails, un administrador de contactos, un reproductor de audios, etc; muchas de estas aplicaciones son de Google y otras son del fabricante del dispositivo, ninguna de ellas se puede desinstalar, a menos que el dispositivo tenga permisos de superusuario (comúnmente se dice que el dispositivo está "rooteado"). El usuario puede instalar aplicaciones que sirven como alternativa a las aplicaciones instaladas por defecto. Android no diferencia entre aplicaciones escritas por los usuarios o provistas por el sistema operativo. Como por ejemplo, el explorador web: un usuario puede descargar Firefox, Opera u otro explorador, sin embargo Android los tratará de la misma forma que el explorador que viene por defecto [ANDSECU]. Los paquetes de instalación (archivos .apk) de las aplicaciones pre-instaladas residen en el directorio /system/app. Las aplicaciones instaladas por el usuario, como también las actualizaciones de las aplicaciones preinstaladas, residen en el directorio /data/app [ANSECIN].

2.4 Desarrollo de aplicaciones en Android

Para empezar a programar aplicaciones para Android es importante tener conocimientos en Java, así como en Programación Orientada a Objetos. También es importante tener noción de XML para definir la parte visual, el cual es un lenguaje descriptivo muy fácil de usar y que aporta simplicidad en el desarrollo de aplicaciones en Android; no obstante, para diseñar la interfase de la aplicación, también se puede acudir a herramientas intuitivas integradas a la IDE, sin escribir código XML.
En la siguiente parte se van a explicar las herramientas principales para poder desarrollar aplicaciones en Android (ambiente y conceptos), de esta forma se trata de demostrar que estan al alcance de cualquier desarrollador y son gratuitas.

2.4.1 Ambiente de desarrollo

El ambiente de desarrollo puede ser usado en los sistemas operativos: Windows, MAC o Linux. Para ello se debe descargar: el SDK de Android (que contiene todas las librerías Java que utiliza Android), el emulador (para probar aplicaciones) y variedad de ejemplos.
Los componentes que forman el entorno de desarrollo de Android son:
- Java: cualquier desarrollador puede descargar gratuitamente un kit de desarrollo de Java (JDK) desde el sitio de Oracle. Funciona en varias arquitecturas y los sistemas operativos mas populares.
- Android Studio: es el IDE oficial de Android, Google se basó en el IDE llamado IntelliJ IDEA de la empresa JetBrains. Antes, se usaba el IDE llamado Eclipse con el plugin "Android Developer Tools" (ADT) que integra este IDE con el entorno de desarrollo de Android; sin embargo, el soporte para Eclipse está finalizando en Android [ECLIPEN].
- Android SDK Manager: es un administrador de paquetes, los cuales pueden ser herramientas complementarias para el SDK, versiones de las plataformas (APIs) para usar en etapa de desarrollo y otros componentes. Este gestor de paquetes facilita el acceso y la administración de herramientas para el entorno de desarrollo. Por ejemplo, desde esta aplicación se puede comprobar si hay nuevos paquetes o add-ons, o actualizaciones de los mismos. Para tener una idea, los paquetes obligatorios a instalar para que compile una aplicación son: SDK Tools, SDK Platform-tools y SDK Platform; también se debe instalar una versión de la API de Android.
- Android Virtual Device (AVD) Manager: es una interfase gráfica para administrar AVDs. O sea, maneja perfiles de dispositivos para realizar pruebas en varios aparatos (simulados).
- Emulador de Android: es una herramienta que emula un dispositivo con Android, esta basado en el emulador QEMU. Generalmente, se lo usa para depurar y probar aplicaciones en tiempo de ejecución en un ambiente actual de Android; no obstante, también se pueden realizar otras tareas, como pentesting. La principal ventaja de esta herramienta es que permite interactuar con un dispositivo con Android sin la necesidad de contar con un dispositivo físico.
- Dalvik Debug Monitor Server (DDMS): esta herramienta realiza diversas tareas, entre ellas se puede mencionar: proporciona servicios de capturas de pantalla del dispositivo, información de la heap y los threads en el dispositivo, logs, información del estado del radio, se pueden simular llamadas entrantes, se puede realizar SMS spoofing, spoofing de los datos de localización geográfica, etc.
- Android Debug Bridge (ADB): es una herramienta de línea de comandos versátil que permite comunicarse con una instancia de emulador de Android o un dispositivo físico con Android.
Cabe mencionar que se pueden usar otros IDEs (por ejemplo, NetBeans), dado que se puede trabajar con un IDE por un lado y a parte se puede usar la línea de comandos para ejecutar la aplicación.

2.4.2 Principales componentes de programación

Para la construcción de una aplicación Android, se emplean los siguientes bloques principales [ANDRFUN]:

{ MOSTRAR PARA CADA UNO: CARACTERÍSTICAS, EJEMPLOS DE USO, ETC. }

. Activities: una activity es una componente de una aplicación que representa una pantalla que provee una interfase de usuario para que el usuario ejecute órdenes. Por ejemplo, un cliente mails podría tener una activity que muestre una lista de e-mails nuevos, otra activity para componer un e-mail y otro para leer mails. Aunque las activities trabajan en forma conjunta para formar una aplicación de gestión mails coherente, cada una es independiente de las otras. De esta forma, otra aplicación puede iniciar cualquier activity de ésta (si lo permite). Por ejemplo, una aplicación que usa la cámara fotográfica puede iniciar la activity que se usa para redactar un mail, con la finalidad de compartir una fotografía del usuario.
{ MOSTRAR CÓDIGO O ALGÚN EJEMPLO O ALGO MÁS TANGIBLE }
	-Una activity tiene estados, un ciclo de vida.
	-Subclase de Activity (o de una subclase existente de Activity).
	-En esta subclase se necesita implementar métodos que el sistema llama cuando ocurre una transición de estados de sus ciclo de vida. Los estados más importantes son: "OnCreate()" que se llama cuando se está creando la activity (aún no está visible) y "OnPause()" que se llama cuando el usuario está dejando la pantalla. El primero principalmente se utiliza para inicializar variables internas y para definir el diseño de la pantalla en función a los recursos (imágenes, etiquetas, etc.); el segundo se utiliza para persistir cambios o guardar el estado de la aplicación.
	-.
Ejemplo:

public class ExampleActivity extends Activity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // Código a ejecutar
    }
    @Override
    protected void onPause() {
        super.onPause();
        // Código a ejecutar
    }
}

[ Fuente: http://developer.android.com/intl/es/guide/components/activities.html ]

. Services: un service es un componente que se ejecuta en background para ejecutar operaciones de larga duración o para realizar una tarea que necesite interactuar con procesos remotos. Un service no provee interfase de usuario. Por ejemplo, un service podría reproducir música en background mientras el usuario interactúa con otra aplicación, o podría extraer datos de la red sin bloquear la interacción que tiene el usuario con la activity actual.
	-Tiene 2 formas: Started y Bound.
[ Fuente: http://developer.android.com/intl/es/guide/components/services.html ]

. Content Providers: un content provider maneja un conjunto compartido de datos de las aplicaciones. Los datos se pueden guardar en varios lugares, como el sistema de archivos, una base de datos SQLite, la Web o cualquier otro lugar de almacenamiento persistente en donde la aplicación tenga acceso; por medio de un content provider las aplicaciones pueden consultar o incluso modificar los datos (si el content provider lo permite). Un content provider también es útil para leer y escribir datos que son privados a la aplicación y no se comparten. Por ejemplo, el sistema provee un content provider que administra los datos de los contactos del usuario.
[ Fuente: http://developer.android.com/intl/es/guide/topics/providers/content-providers.html ]

. Broadcast Receivers: un broadcast receiver es un componente que reacciona ante las notificaciones que se difunden a todo el sistema. Muchos broadcasts se originan desde el sistema; por ejemplo, un broadcast que anuncia que la pantalla se ha apagado, otro que indica que la batería esta baja o que una fotografía fue tomada. Las aplicaciones también pueden iniciar broadcasts; por ejemplo, para permitir que otras aplicaciones sepan que algunos datos han sido descargados al dispositivo y ya estan disponibles para que los usen. A pesar de que los broadcast receivers no disponen de una interfase de usuario, ellos pueden crear una notificación para que se vea en la barra de estado y alertar al usuario que surgió un evento del tipo broadcast. Sin embargo, usualmente un broadcast receiver es sólo una "puerta" a otros componentes y pretende realizar una cantidad mínima de trabajo. Por ejemplo, un broadcast receiver podría disparar un servicio para ejecutar algún trabajo basado en el evento que le fue notificado.
[ Fuente: http://developer.android.com/intl/es/reference/android/content/BroadcastReceiver.html ]

. Intents [ANDRINT]: los intents son mensajes que sirven para activar 3 componentes claves de una aplicación: activities, services y broadcast receivers. El envío de intents tiene la finalidad de relacionar componentes en tiempo de ejecución, ya sean de diferentes aplicaciones o de la misma aplicación, que cuando son recibidos por services o activities pueden activar procesos. Internamente, un intent es una estructura de datos pasiva que posee una descripción abstracta de una operación a ejecutar o en el caso de los intents de tipo broadcast, una descripción de algo que ya ha sucedido y esta siendo notificado.
. Views [ANDRVIE]: todos los elementos de la interfase de usuario en una aplicación se construyen usando objetos tipo View y ViewGroup. Un View es un objeto que dibuja una figura en la pantalla con que el usuario puede interactuar. Un ViewGroup es un objeto que puede contener objetos de tipo View y a la vez, puede contener objetos ViewGroup, esta estructura se usa para definir la presentación de la interfase. Asimismo, todo componente que posea una interfase de usuario se la define usando una jerarquía de objetos View y ViewGroup. Esta jerarquía forma un árbol que puede ser tan complejo o tan simple como se requiera, no obstante la simplicidad mejora el rendimiento de la aplicación. Android provee una colección preparada de subclases View y ViewGroup, que ofrecen controles de entrada de uso común (como botones y campos de texto) y varios modelos de presentación (las cuales definen la disposición de los controles [ANDRLAY]). Para declarar una capa de presentación (layout), se puede optar por 2 opciones. La primera consiste en instanciar objetos Views en el código que se vá a ejecutar y empezar a construir un árbol de objetos View y ViewGroup en tiempo de ejecución. La segunda opción, la más sencilla y más efectiva, consiste en definir la capa de presentación en un archivo XML; los archivos XML ofrecen una estructura razonablemente legible, son similares al formato HTML.
. Manifest: un manifest es un archivo XML en donde se declaran todos los componentes de una aplicación, este archivo se debe ubicar en la raíz del directorio del proyecto de la aplicación. Además, cumple otras funciones importantes como:
- Identificar los permisos que debe conceder el usuario para que la aplicación se instale. Por ejemplo, el acceso a Internet o el acceso de lectura a los contactos del usuario.
- Definir el nivel de API mínimo que requiere la aplicación, ésto se basa en las APIs que utiliza la aplicación.
- Definir los requerimientos de hardware y software de la aplicación, tal como la cámara fotográfica, servicios de bluetooth o una pantalla multitouch.
- Definir los enlaces externos con las bibliotecas ajenas a la API nativa de Android, tal como la biblioteca de Google Maps.

2.4.3 Distribución

En Android, los desarrolladores pueden elegir un método para distribuir aplicaciones o pueden combinar. Los procesos para empaquetar y distribuir aplicaciones son independientes. Asimismo, en esta instancia se pueden distinguir dos tareas principales [PLAYPUB]:
- Se prepara la aplicación para la publicación (es el proceso de empaquetado), se construye un paquete instalador de la aplicación, con que los usuarios van a poder descargar e instalar en sus dispositivos con Android.
- Se publica la aplicación, durante esta fase se difunde la aplicación con publicidad, se vende y distribuye la versión de producción de la aplicación.
Un método posible para distribuir aplicaciones es a través de un marketplace; por lo general, con este método se puede llegar a la mayor cantidad de usuarios posible que con los otros métodos. Por ejemplo, Google Play es el principal marketplace para las aplicaciones de Android y es particularmente útil si se desea distribuir aplicaciones a una gran público global. Sin embargo, se pueden distribuir aplicaciones a través de cualquier otro marketplace o usar varios [OPENDIS]. Otros marketplaces posibles pueden ser [ALTMARK]: Amazon Appstore [AMAZAPP], Slide Me [SLIDEME], AppsLib [APPSLIB], Insyde Market [INSMARK], FileDir [FILEDIR], AppBrain [APPBRAI], Android Pit [ANDRPIT], F-Droid [FDROIDM], entre otros.

2.4.3.1 Google Play

Google Play es una plataforma de distribución digital operada por Google, es el marketplace oficial de Android, originalmente se llamaba "Android Market". Permite a los usuarios navegar entre miles de aplicaciones para luego descargar las que seleccionen. Permite a los desarrolladores publicar sus aplicaciones desarrolladas con el SDK de Android. Además de distribuir aplicaciones, también sirve como almacén de medios digitales, ofreciendo música, revistas, libros, películas y programas de televisión [WIKPLAY][PLAYOVE].
Entre las facilidades que Google Play ofrece al desarrollador, está el control sobre el alcance que tienen sus aplicación en base a las características del dispositivo del usuario (por ejemplo, la versión de Android y las características del hardware), por lo tanto algunos usuarios no van a poder instalar ciertas aplicaciones por las restricciones del desarrollador; no obstante, para aumentar el alcance de la aplicación, el desarrollador puede considerar la ausencia de los requisitos y publicar versiones alternativas para ellos. Además, Google Play permite el uso de 2 servicios: el servicio de licencias y el servicio de facturación dentro de la aplicación. El primer servicio proporciona ayuda para prevenir la instalación y uso no autorizado de las aplicaciones; el segundo servicio facilita la venta integrada dentro de las aplicaciones, por ejemplo cuando una aplicación ofrece una actualización que tiene un cargo económico [OPENDIS][WIKPLAY].
Para que un desarrollador se dé de alta en Google Play, debe realizar una serie de pasos. Por empezar, debe tener una cuenta Google para asociarla a la futura cuenta del desarrollador, se puede utilizar una ya existente o bien se puede crear una. Al iniciar el proceso de creación de una cuenta, se debe leer y aceptar un acuerdo en el cual se dan a conocer todas las normas que deberá cumplir el desarrollador a la hora de distribuir su trabajo a través del marketplace. Luego deberá pagar un arancel único, acto seguido el desarrollador deberá rellenar un formulario de registro con su información personal. Una vez que un desarrollador termina de registrar y validar su cuenta de Google Play, podrá acceder a estos datos y modificarlos siempre que lo desee. Tras la realización de la solicitud, el desarrollador recibirá en 24 o 48 horas un correo confirmando el registro y validando su cuenta, cuando lo reciba, podrá acceder con su cuenta a la consola de desarrollador Android de Google Play y comenzar a subir aplicaciones [ALTPLAY][PLAYREG].
En cuanto a las tarifas, para registrarse en Google Play existe una tarifa única de 25 USD [PLAYREG] (este abono se realiza a través de Google Wallet [ALTPLAY]), en contraste con aplicación Store (el marketplace de Apple) que cobra una cuota anual de 99 USD como mínimo [APPFEES]. Luego, por cada aplicación o producto integrado en una aplicación que se vende, Google Play cobra una tarifa de transacción equivalente al 30% del precio del producto. Es decir, que el desarrollador recibe el 70% del pago (igual que en aplicación Store de Apple [APPLEPA]), el 30% restante se destina al socio de distribución y a las comisiones [PLAYAPP].
Desde el punto de vista del usuario de aplicaciones, en Google Play se cuenta con un conjunto de herramientas como las calificaciones y comentarios que exponen la experiencia que tuvieron los usuarios con una aplicación en particular. Esta información se la puede tomar como un punto de referencia clave acerca de la calidad de la aplicación. La calificación que le asignan los usuarios a las aplicaciones es uno de los factores más importantes que influyen en el ranking que se va formando en las listas de aplicaciones por categoría y los resultados de búsqueda de Google Play, también influyen en las listas que presentan selecciones de aplicaciones y juegos para la promoción en el marketplace.
Asimismo, el usuario puede explorar las aplicaciones por categorías (hay más de 30), en cada categoría se presentan listas de aplicaciones ordenadas por una combinación de factores: rating, críticas de los usuarios, cantidad de descargas, país y otros. El usuario también puede ubicar las aplicaciones que quiere por las búsquedas, las cuales permiten llegar a la aplicación que necesita con mayor precisión; la búsqueda tiene características adicionales, como sugerencias de términos más relevantes o nombres de las aplicaciones más populares que se acerquen al término buscado. Igualmente, el usuario tiene a disposición listas de aplicaciones que tienen las mejores puntuaciones, divididas en categorías como: aplicaciones gratuitas, pagas, nuevas, las que crecieron con mayor rapidez, entre otras; constantemente se están creando listas de aplicaciones basadas en un tema o acontecimiento estacional, tratando de promocionar aquellas que son de mejor calidad. De hecho, hay un apartado en donde realizan reconocimientos, como por ejemplo "el mejor desarrollador". [PLAYABO]

2.4.3.2 Otros métodos de distribución

Otro métodos de distribución (una alternativa al marketplace), es el envío de aplicaciones a los usuarios por email, la cual es una forma fácil y rápida de publicar una aplicación. Para utilizar esta forma, se prepara la aplicación para la publicación (empaquetado), se adjunta en un email y se lo envía a un usuario. Cuando el usuario abre el mensaje de email en el dispositivo con Android, el sistema reconoce el paquete de instalación (archivo .apk) y muestra un botón que indica si se quiere instalar la aplicación. La distribución de aplicaciones por email es conveniente si se lo envía a unos pocos usuarios de confianza, dado que esta forma de distribución proporciona pocas protecciones contra la piratería y la distribución no autorizada [OPENDIS].
Finalmente, se pueden distribuir aplicaciones a través de un sitio Web. Es posible poner a disposición una aplicación para su descarga en un sitio web. Para realizar esta distribución, primero se debe preparar el paquete de la aplicación para publicarlo (empaquetado); luego, todo lo que se necesita hacer es alojar el archivo .apk en el sitio web y habilitar un link de descarga para los usuarios. Cuando los usuarios accedan al enlace de descarga desde sus smartphones con Android, el archivo se descargará y el sistema Android automáticamente iniciará la instalación. Sin embargo, la instalación comenzará automáticamente sólo si los usuarios tienen configurado al sistema de forma tal que permita la instalación desde fuentes desconocidas [OPENDIS].