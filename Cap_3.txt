Capítulo 3

Seguridad en Android

3.1 Objetivo

El objetivo general del capítulo es mostrar qué herramientas incorpora Android para defender la seguridad del usuario.
Concretamente, se explica el modelo de seguridad que provee Android y se describen los mecanismos adicionales que se emplean para mitigar riesgos. La primer parte se enfoca en 3 pilares: el kernel de Android, el sistema de permisos y el firmado digital de aplicaciones. En la segunda parte se describen las herramientas adicionales.

3.2 Modelo de seguridad

Android utiliza 2 modelos de permisos separados en capas que cooperan para alcanzar un objetivo compartido. Por un lado, en el nivel más bajo hay un kernel de Linux modificado que implementa los permisos basándose en un modelo "sandbox", el cual es transparente al usuario. Por otro lado, en la capa donde se encuentran las aplicaciones que interactuan con el framework de Android, el nivel mas alto de la pila de capas, se encuentra el segundo modelo. Este modelo es visible por los usuarios cuando ellos estan por instalar aplicaciones y pueden ver una lista de permisos correspondiente a una aplicación. Esta lista es definida por el autor de la aplicación y describe las aptitudes que necesita la aplicación por parte del sistema.

3.2.1 Kernel de linux

Dado que el kernel de Android esta basado en el kernel de Linux, el cual es bastante maduro en materia de seguridad, le atribuye a Android las siguientes características [SECKERN]:
.Aislación de procesos (modelo Sandbox).
.Mecanismo extensible para un IPC confiable (Binder).
.Un modelo de permisos basado en el usuario (uso de UID).
.Aislación de los recursos que pertenecen a un usuario (permisos en los archivos del filesystem).
Primero se va a revisar el modelo de seguridad básico en Linux y luego se verá de qué forma se usa este modelo en Android.
En el contexto de la seguridad en Linux, se utilizan 2 conceptos importantes en relación a los usuarios: UID y GID. El UID es un identificador que se le asigna a cada usuario. El GID es un identificador que se le asigna a cada grupo de usuarios. Por otro lado, cada recurso tiene asignado un conjunto de permisos, por lo general, un recurso es un archivo. Los recursos tienen asignados 3 grupos de permisos basados en el usuario: un dueño, un grupo y el resto de los usuarios; cada grupo de permisos consta de los siguientes permisos basados en el recurso: lectura, escritura y ejecución (permite que el archivo sea tratado como un código ejecutable). Todos estos conceptos juntos persiguen un objetivo: evitar el acceso de cualquier aplicación a los datos, procesos y espacio de memoria ajenos a ella. Asimismo, se realiza una agrupación de los recursos por cada aplicación, cada miembro del grupo de recursos tiene asignado un UID como dueño [LINPERM].
En Android se aprovecha esta característica. A cada aplicación instalada se le asigna un UID, con lo cual esta aplicación corre bajo ese usuario (UID) en un proceso separado y todos los datos que se van almacenando serán propiedad de este UID (se les asignará este UID como dueño), ya sea un archivo, una base de datos u otro recurso. Se aprovecha el concepto de usuario único de Linux para aplicar la aislación de aplicaciones en Android. Por defecto, se aplica un régimen de aislación estricto para todas las aplicaciones, es decir que las aplicaciones no pueden interactuar entre sí a menos que se definan configuraciones adicionales, y lo mismo pasa con el acceso a las funciones del sistema operativo. Concluyendo con un ejemplo, si la aplicación A intenta hacer algo malicioso como leer datos de la aplicación B sin su consentimiento o hacer llamadas teléfonicas sin los permisos correspondientes, entonces el sistema operativo protegererá a la aplicación B o denegará la realización de la llamada, porque la aplicación A no tiene los privilegios de usuario debidos. Esta aislación y asignación de UID a procesos es lo que forma el modelo de Sandbox de aplicaciones a nivel de kernel.
El modelo Sandbox es simple, auditable y maduro, dado que en los sistemas basados en Unix hace mucho que se lo viene utilizando. Debido a que el modelo Sandbox se aplica a nivel del kernel, el mismo se extiende a las capas superiores. Para cada proceso, este modelo se emplea de la misma forma y con el mismo grado de seguridad. Como cualquier medida de seguridad, este modelo no es infalible, pero para evadirlo (en un dispositivo configurado apropiadamente) se necesita corromper la seguridad del kernel de Linux. El modelo Sandbox modera las catástrofes originadas por la corrupción de memoria, limitando los efectos a un contexto particular de un proceso y no al resto del sistema, este problema pasa cuando los contenidos de una ubicación de memoria son modificados involuntariamente debido a errores de programación.
En el Filesystem también se aplica el modelo de seguridad sandbox para prevenir que cada aplicación acceda a los archivos de cualquier otra (que tenga distinto UID). Cada aplicación guarda sus archivos en una ruta del estilo /data/data/{app_name} , en donde {app_name} es el nombre de la aplicación, entonces el sistema configura este directorio de la siguiente forma: sólo se establecen los permisos del dueño, con el UID de la aplicación; ningún otro UID (aplicación) va a tener acceso porque ni los permisos del grupo, ni los permisos globales son definidos. Cuando la aplicación cree nuevos archivos, sus permisos se definirán de la misma forma. Por ejemplo, ésto sucede dentro del directorio /data/data/{app_name}/files, en donde se van creando archivos durante la instalación y ejecución de la aplicación. Sin embargo, se puede programar la aplicación para que los archivos que se van creando puedan ser accedidos por otras, ésto se logra alterando los permisos que vienen por defecto. O dicho de otra forma, cualquier aplicación que es configurada para correr con el mismo UID de otra aplicación puede acceder a sus archivos; generalmente ésto se realiza sólo si se necesita compartir recursos y sucede con todas las aplicaciones originadas por el mismo desarrollador; cualquier aplicación nueva que comparta el UID con una aplicación ya instalada (y con la definición de algunas configuraciones adicionales), tendrá control total con los archivos de la aplicación asentada [APPSECU].

3.2.2 Permisos

En el archivo de configuración de una aplicación hay una lista de permisos, la cual sirve para definir explícitamente los accesos que va a tener la aplicación a recursos y funciones del sistema (por defecto, Android no otorga ningún permiso), esta lista la define el autor de la aplicación en un archivo llamado manifiesto ("AndroidManifest.xml"). Para el usuario de aplicación, estos permisos advierten de las operaciones que son potencialmente peligrosas y que se llevarán a cabo una vez que la aplicación sea instalada.
El modelo de solicitud de permisos se acciona justo antes de instalar una aplicación, en ese instante el usuario deberá leer y aceptar (o rechazar) la lista de permisos; cuya aprobación no es individual o parcial sino total, por lo tanto sólo hay 2 alternativas: o se aceptan todos o ninguno de los permisos de una aplicación, lo que produce la continuación o la cancelación de la instalación, respectivamente. Una vez que los permisos son otorgados, el sistema no notifica al usuario otra vez que los permisos fueron concedidos, esto se realiza así para evitar confusiones y mejorar la experiencia del usuario, en vez de proveer confirmaciones reiteradas que perjudican la interacción con el dispositivo. Los permisos son eliminados si una aplicación es desinstalada, entonces en una subsecuente reinstalación se preguntará nuevamente por los permisos. El usuario tiene la posibilidad de ver los permisos otorgados a las aplicaciones previamente instaladas, están dentro de las propiedades de la aplicación. En el caso de que una aplicación intente usar una función sensible que no ha sido declarada en el manifiesto como permiso, generalmente produce una excepción de seguridad denominada "SecurityException" [SECPERM].
Hay 2 tipos de permisos: los permisos por defecto que trae el sistema y los permisos definidos por la aplicación.
Este modelo tiene 2 ventajas principales sobre los modelos más tradicionales [SECOVER]. Primero, un usuario puede ver todas las acciones riesgosas que sería capaz de hacer la aplicación antes de ser instalada y además se puede comprobar si la lista de permisos es coherente con respecto al propósito de la aplicación antes de aceptarla, si coinciden con sus necesidades y espectativas. Por ejemplo, un usuario que descarga un juego que corre completamente de forma local (sin la necesidad de acceder a una red) vé que pide permisos para acceder a los mensajes SMS, hacer llamadas telefónicas y obtener acceso completo a Internet, lo cual no tiene fundamento y probablemente el usuario decidirá abortar la instalación. También es importante destacar que en el proceso de revisión de permisos, el usuario aún no ha establecido un compromiso mental o financiero con la aplicación y se puede comparar fácilmente con otras aplicaciones alternativas.
Segundo, este modelo de permisos permite la contención de un ataque de una aplicación maliciosa sobre otras aplicaciones genuinas y permite limitar el daño que pueda llegar a realizar una aplicación maliciosa en función de los permisos concedidos. Por ejemplo, existen ciertas aplicaciones que tienen errores de programación, y en muchos casos, estos errores le permiten a los delicuentes expertos en informática dominar a la aplicación que está corriendo y provocar que su propio código arbitrario corra en el mismo contexto que la aplicación comprometida; en Android, una aplicación expuesta ejecutará el código arbitrario del atacante con los privilegios que le fueron concedidos, ergo sus acciones serán circunscriptas a los permisos que aquella aplicación ha declarado y se le han otorgado.
Mas allá de las ventajas de los permisos, uno se puede preguntar: ¿Los usuarios aprobarán cualquier conjunto de permisos pertenecientes a una aplicación determinada ó ellos prestarán atención lo que contiene la lista que ellos deben aceptar para la instalación? El modelo de permisos sólo es válido si los usuarios son conscientes de lo que hacen. Primordialmente, no hay una forma para forzar a un usuario a que efectivamente entienda lo que esta aceptando. Debido a esta cuestión, las descripciones para los permisos usualmente son cortas y fáciles de entender.

3.2.3 Firmado digital

[MAPA]
En esta sección se explica el mecanismo del firmado digital con certificado en las aplicaciones Android, tema que los desarrolladores deben considerar cuando publican aplicaciones. Antes de explicar el tema central, se entrará en contexto introduciendo los conceptos generales involucrados. Primero, se describe la idea de la encriptación asimétrica. Segundo, se exponen los puntos esenciales de las firmas digitales. Tercero, se muestra la idea del uso de un certificado. Finalmente, se explica como se aplica el firmado digital con certificado en Android (con un ejemplo práctico incluido).

{ ¿Qué es la clave? }
{ ¿Una intro básica de la criptografía ? }

[CRIPTOGRAFÍA DE CLAVE PÚBLICA]
La encriptación asimétrica (también llamada encriptación de clave pública) convierte un texto plano a un texto encriptado usando una clave y un algoritmo de encriptación. Luego con otra clave y un algoritmo de desencriptación se puede recuperar el texto plano a partir del texto encriptado. En la encriptación asimétrica se usa una clave para la ejecución de la encriptación y otra distinta para la desencriptación. Estas claves corresponden a: una clave pública, que se puede compartir, y una clave privada, que se debe ocultar para que nadie tenga acceso a ella, la asociación entre cada clave con cada operación (encriptación o desencriptación) dependerá de su aplicación (pronto se explicará este punto).
Teniendo en cuenta un marco general, en donde un remitente y un destinatario intercambian mensajes encriptados en un medio inseguro. El uso de claves distintas para cada operación criptográfica evita el problema del intercambio de claves entre las personas, cuestión que acarreaban los sistemas de encriptación simétricos (sistemas que utilizan la misma clave para la encriptación y desencriptación). De esta forma los sistemas de encriptación de clave pública se libran de la elaboración de un mecanismo de distribución de claves [CRYPSTA]. En conclusión, la encriptación simétrica requiere que el remitente y el destinatario compartan una clave de sesión, para usarla tanto en la encriptación como en la desencriptación. En cambio, en la encriptación asimétrica, solo se necesita que el remitente adquiera una copia de la clave pública del destinatario, antes de iniciar una comunicación secreta.
Existen varias implementaciones de la encriptación asimétrica, por lo general sus especificaciones técnicas son públicas, éstas describen el procedimiento para encriptar, desencriptar y generar las claves (la clave privada y su correspondiente clave pública). Según el Principio de Kerckhoffs [SISMODE], los algoritmos de encriptado y desencriptado siempre deben ser públicos y el secreto debe residir exclusivamente en las claves. La implementación más usada del sistema de clave pública es el sistema RSA.
Una de las contribuciones de la encriptación asimétrica es una implementación del mecanismo de la firma digital [CRYPSTA]. En líneas generales, la firma digital es un método que establece la identificación del autor de un mensaje (autoría del mensaje). En la encriptación asimétrica, la firma digital se basa en que un emisor encripta un mensaje con su clave privada y lo envía al receptor, éste puede descifrar el mensaje con la clave pública que el emisor puso a disposición. Si se tiene en cuenta que el mensaje se encripta usando sólo una clave privada que posee el emisor, o sea que sólo éste podría haber preparado el mensaje encriptado; entonces, todo el mensaje encriptado sirve como una firma digital [CRYPSTA]. 
Otra contribución de la encriptación asimétrica es el fortalecimiento de la privacidad en los mensajes que se transmiten. Este avance consiste en que un emisor puede usar una clave pública provista por el destinatario para encriptar un mensaje, usando el algoritmo de encriptación. Cuando el receptor recibe el mensaje encriptado lo podrá desencriptar con su clave privada y sólo él podrá descifrarlo mientras esconda esta clave.

[GRAFICO BÁSICO DE ENCRIPTACIÓN ASIMÉTRICA - ENCRIPTADO - FIRMADO]

El esquema básico de la firma digital fue mejorado, a continuación se explicará este avance [INFOSEC]. En realidad, los mensajes firmados que el emisor envía al receptor se componen de 2 elementos: el mensaje original sin encriptar (texto plano) y la versión encriptada de este mensaje. Con éstos 2 componentes se puede verificar la autoría y la integridad del mensaje, este último se realiza descifrando el mensaje encriptado con la clave pública y comparando su resultado con el mensaje original. Sin embargo, este esquema de firma digital genera un problema potencial: el espacio consumido por el mensaje firmado es el doble de grande (o más) que el mensaje original sin firmar. Esta situación se puede mejorar con la encriptación de un pequeño bloque de bits llamado message digest. El message digest es una representación más ligera de un archivo, está basado en su contenido; se obtiene por medio de una función matemática llamada función de hash, la cual recibe como entrada a los datos que contiene un archivo. Concluyendo, el proceso de la firma consta de los siguientes pasos: se obtiene el message digest del mensaje, se lo encripta con la clave privada del emisor y el resultado (firma digital) se lo anexa al mensaje original para enviarlo al destinatario.

Resumiendo, se mostraron 2 formas de uso de la encriptación de clave pública [CRYPSTA]:
Encriptado y desencriptado: el emisor encripta un mensaje con la clave pública del destinatario y envía el mensaje (transformado) que no puede ser descifrado por nadie, excepto por el poseedor de la clave privada correspondiente, (el cual debería ser su propietario y creador de ambas claves). Con este mecanismo se garantiza la confidencialidad del mensaje.
Firmas digitales: el emisor genera una firma con el contenido del mensaje y su clave privada, para luego envíar el mensaje junto con la firma. Ésta permite comprobar su integridad y su origen por cualquiera, usando la clave pública difundida por el emisor. La firma se genera aplicando un algoritmo de encriptación que recibe un pequeño bloque de datos que simboliza al mensaje original, en vez de usar el mensaje entero. Con la firma digital se garantiza la legitimidad y la autoría del mensaje.
Cabe destacar que la técnica del firmado digital descrita no garantiza confidencialidad. Dado que un mensaje firmado empaqueta el texto plano original y la firma digital, cuando se filtra un mensaje, es posible obtener el contenido original. La garantía de la privacidad en los datos es casi siempre importante, por lo que el mensaje firmado se suele encriptar [INFOSEC]. A continuación, se detallará la idea de la firma digital, y luego, se describirá el concepto de certificado digital.

[FIRMA DIGITAL repaso y más en detalle; luego, CERTIFICADO por arriba]
{ PROPIEDAD DE NO REPUDIOOOO!!!! }

[FIRMA DIGITAL - DEFINICIÓN CONCRETA Y SIMPLE]
Una firma digital es un mecanismo de autenticación que consiste en la vinculación entre un mensaje y un código que actúa como una firma [CRYPSTA]. Los mensajes se pueden firmar digitalmente con el fin de identificar al autor del mensaje (autoría), y también para comprobar si el mensaje fue adulterado (integridad). Este mecanismo se lo puede utilizar para firmar e-mails, documentos digitales y archivos. En el contexto de la firma digital, se pueden distinguir 2 operaciones: firmado (por parte del emisor) y verificación (por parte del destinatario del mensaje); éstas se basan en las operaciones primitivas de encriptado y desencriptado, respectivamente.

[GRÁFICO - FIRMA DIGITAL - BASICO]

[FIRMADO DIGITAL - PROCEDIMIENTO]
A continuación se describirá la forma de proceder cuando un emisor quiere envíar mensajes firmados digitalmente a un destinatario [SISMODE]. Al inicio, antes de firmar cualquier mensaje, tanto el emisor como el receptor se deben poner de acuerdo con el esquema de firmado que van a utilizar (por ejemplo, RSA), este esquema define los algoritmos de generación de claves, los algoritmos de firmado y verificación. Una vez definido ésto, el emisor debe generar las claves.
Cuando una persona quiere firmar digitalmente un mensaje, comienza con la obtención del valor de la función de hash, que recibe como entrada a todo el contenido del mensaje y produce una representación codificada del mensaje (message digest), es un código de longitud fija, sea cual fuese el tamaño del mensaje original [JARSINT]. La función de hash es sensible al contenido del mensaje, es decir que el valor que retorna va a cambiar si y sólo si el mensaje en sí mismo cambia. A veces, se relaciona la función de hash con otras funciones similares como digital fingerprint y checksum, éste último tiene otros propósitos. Los algoritmos más populares que implementan funciones de hash son: MD5 y SHA-1, los cuales producen un resultado de 16 y 20 bytes, respectivamente; también hay otras versiones más actuales de SHA-1 como SHA-256 y SHA-512, que producen resultados de 32 y 64 bytes, respectivamente. Luego de obtener el message digest del mensaje, se lo codifica utilizando el algoritmo de encriptación con la clave privada, este código representa la firma digital del mensaje, se lo llama Bloque de Firma. Por último, se anexa el Bloque de Firma al mensaje original y se lo envía al receptor.
Cuando otra persona recibe el mensaje firmado digitalmente (el mensaje original con el Bloque de Firma adjunto), se calculan 2 valores y se los compara, con el fin de comprobar la integridad y autoría del mensaje. El primer valor a calcular se lo obtiene con la función de hash del mensaje original (sin el Bloque de Firma) usando un algoritmo como MD5 o SHA, u otro que se haya acordado de antemano. El segundo valor se obtiene con el uso del algoritmo de desencriptación que recibe el Bloque de Firma y la clave pública, debería retornar el valor de hash del mensaje original. Si estos 2 valores no son iguales, quiere decir que de alguna forma se adulteró el mensaje o el Bloque de Firma o ambos (pérdida de integridad); o también puede ser que la firma fue creada con una clave privada que no corresponde con la clave pública presentada por la persona que la firmó (pérdida de autoría), o sea que sólo el remitente pudo haber generado la firma, si es que se puede revertir con el algoritmo de desencriptación y su clave pública [SECINCO].

[GRÁFICO - FIRMA DIGITAL - OPERACIONES]

[CERTIFICADOS - DEFINICIÓN CONCRETA, CORTA Y SIMPLE]
En el marco de la firma digital, una cuestión a considerar es la distribución de claves. Considerando el siguiente contexto: suponiendo que se puede utilizar algún método para entregar claves públicas inventadas a un emisor de mensajes, haciéndole creer que provienen de un receptor conocido y confiable; y suponiendo que se puede interceptar transmisiones entre un emisor y un receptor. Entonces, un atacante puede generar un par de claves (privada y pública) y enviar su propia clave pública al emisor, y dado que este emisor va a creer que esa clave pública pertenece a un receptor conocido, entonces el atacante puede interceptar cualquier texto encriptado enviado por el emisor y descifrarlo con su propia clave privada. Luego puede guardar una copia del mensaje decodificado, cifrar el mensaje decodificado con la clave pública del receptor y enviarlo a este receptor. En principio, ni el receptor, ni el emisor van a detectar la presencia del atacante. Para resolver este problema, usualmente los emisores adjuntan un certificado al mensaje, a continuación se exponen algunas de sus definiciones.
	"Un certificado (también conocido como certificado de clave pública) es una declaración firmada digitalmente por una entidad (el editor), diciendo que la clave pública (y algún datos más) de otra entidad (el sujeto) tiene un valor específico." [KEYTOOL]
	"Un certificado es una declaración firmada digitalmente por una Autoridad de Certificación reconocida que indica quien es el duelo de una clave pública específica." [JARSINT]
	"Una clave pública y la identidad del usuario estan unidos en un certificado, que luego es firmado por alguien llamado Autoridad de Certificación, certificando la precisión de la unión." [SECINCO]
Las Autoridades de Certificación (CA - Certification Authority) son entidades que son confiables para firmar certificados de otras entidades [KEYTOOL]. Se supone que estas Autoridades convertirán a los certificados sin firmar que reciban en certificados válidos y fiables, ya que están obligados por acuerdos legales. Hay muchas Autoridades de Certificación como VeriSign, Thawte, Entrust, etc.
Un certificado firmado contiene básicamente cuatro elementos [CRYPSTA]:
- Información que identifica a una entidad (un usuario o una organización).
- La clave pública de la entidad.
- Información de la Autoridad de Certificación.
- Una firma digital del certificado, generada por una Autoridad de Certificación.

[ GRÁFICO - "DIGITAL CERTIFICATE" ]

En líneas generales, el procedimiento de certificación funciona de esta forma [SECINCO]: suponiendo que existe una Autoridad de Certificación que generó sus claves y difundió la parte pública. Entonces, un emisor de mensajes genera sus claves, coloca su clave pública en un mensaje junto con la información que lo identifica y envía el mensaje de forma segura (usando la clave pública difundida) a la Autoridad de Certificación. Ésta recibe el mensaje y lo firma digitalmente: genera el valor de hash del mensaje y lo encripta con la clave privada; esta firma es adherida al mensaje y se lo retorna al emisor. Esto quiere decir que la Autoridad de Certificación certifica con esta firma digital, que la clave pública del emisor de mensajes y su identidad, que contiene el mensaje, pertenecen a la misma persona. Este mensaje firmado por la Autoridad de Certificación es el certificado del emisor.

[ FIRMADO EN JAVA / ANDROID]
En el marco de las firmas y certificados digitales, se verá a continuación cómo se usan las ideas explicadas anteriormente en Android. Todas las aplicaciones Android, incluyendo las del sistema, deben ser firmadas con un certificado digital que identifique a su autor; en realidad, se firman los archivos APK, los cuales empaquetan aplicaciones para poder intalarlos. Android hereda el firmado de aplicaciones de Java [ANSECIN]. De hecho, el formato de los archivos APK de Android son una extensión del formato de los archivos JAR de Java [ANSECIN]. Estos archivos JAR (Java ARchive) se los utiliza usualmente para distribuir aplicaciones o librerías para la plataforma Java. Un archivo JAR consiste de archivos binarios de Java, recursos y otros archivos que están comprimidos en el formato ZIP; pero lo que interesa en este contexto, es que dentro de este archivo comprimido (al igual que los archivos APK) hay una carpeta llamada "META-INF" que contiene archivos relacionados con la firma digital. En Java es habitual que un certificado digital sea firmado por una Autoridad de Certificación, pero en Android esto no es necesario; de hecho, frecuentemente las aplicaciones de Android usan certificados auto-firmados (el mismo desarrollador puede generar el certificado). Ésto disminuye los costos relacionados al certificado y simplifica el proceso de publicación [IBMASEC].

Éstos son motivos por los cuales se debe firmar una aplicación digitalmente:
+ Asegurar la pertenencia: sólo el autor de una aplicación puede generar firmas con su clave privada. Por lo tanto, se pueden recibir actualizaciones de su aplicación confiando que provienen del mismo autor.
+ Proporciona integridad: significa que la firma digital permite comprobar si el archivo APK no ha sido modificado, ni alterado [KEYTOOL].
+ Proporciona autenticidad: significa que el archivo APK viene de quien afirma haberlo creado y firmado [KEYTOOL], el poseedor de la clave privada. Sólo los autores o dueños de la aplicación pueden modificarla y pueden producir un certificado digital válido para sus aplicaciones.
+ Para poder distribuir e instalar la aplicación sin problemas: si la aplicación no se firma digitalmente, será rechazada cuando se la intente instalar en algún dispositivo con Android. Ésto es debido a que el archivo APK será verificado mediante el Administrador de Paquetes (Package Manager) de Android, el cual comprueba si ha sido correctamente firmada con un certificado digital. Asimismo, si se desea publicar la aplicación en Google Play, el archivo APK será verificado para rechazar aquellas aplicaciones no estan firmadas [SOAPPSE].

Para poder firmar un archivo JAR se usan 2 herramientas: keytool y jarsigner.

[GENERAR CLAVES]
Para poder firmar aplicaciones, primero se debe generar un par de claves (una clave privada y una clave pública) y un certificado asociado [IBMASEC]. En Java (y Android), se usa la herramienta keytool para que los usuarios puedan administrar sus propios pares de claves y los certificados asociados a cada par. Con esta herramienta, el usuario mismo puede firmar los certificados y no necesita la intervención de una Autoridad de Certificación [KEYTOOL]; también puede importar, exportar y mostrar certificados. La herramienta keytool almacena las claves y certificados en un keystore [KEYTOOL]. Un keystore es un archivo binario que representa a un almacén (es una base de datos) que está protegido por una contraseña, en este almacén guarecen pares de datos (entradas) que se componen de una clave privada y un certificado; cada entrada tiene un nombre (alias) que lo identifica y también está protegido por contraseña [KEYTOOL]. La contraseña de una entrada se exige en el momento en que un usuario firma una aplicación con la clave privada de esa entrada dentro de un keystore (además de pedir la contraseña de este keystore). El keystore le facilita al desarrollador la custodia de varias claves privadas, porque aloja todas ellas en un archivo protegido.

[FIRMAR CON LAS CLAVES]
Luego, para firmar y verificar la firma de archivos JAR (y APK) se usa la herramienta jarsigner [JARSIGN]. Esta herramienta genera la firma con una clave privada del usuario, también guarda una copia del certificado en el archivo JAR (o APK), esencialmente para tener la clave pública a disposición en caso de que se precise verificar la firma. La herramienta jarsigner obtiene la clave privada y el certificado por medio de un keystore especificado por el usuario, luego le pide la contraseña del keystore y la contraseña para acceder a la clave privada. El comando jarsigner retorna el mismo archivo (JAR o APK) que ingresó, pero coloca 3 archivos adicionales en la carpeta "META-INF" (si ya existen, entonces los sobreescribe) [JARSINT]:
- Un archivo de texto plano llamado MANIFEST.MF que tiene la siguiente estructura: se definen 2 líneas de texto por cada archivo que contiene el archivo JAR. Cada par de líneas de texto contiene: el nombre del archivo y su valor de hash (junto con el algoritmo de hash empleado).
- Un archivo de firma con la extensión .SF (signature file) es un archivo de texto plano que respeta el mismo formato que MANIFEST.MF. Sin embargo, el valor de hash de cada archivo que contiene el archivo JAR, se calcula a partir del par de líneas de texto que le corresponda al archivo en MANIFEST.MF [JARSIGN]. Al principio de MANIFEST.MF hay un valor de hash correspondiente al contenido del archivo MANIFEST.MF entero.
- Un archivo de Bloque de Firma puede tener la extensión .DSA, .RSA o .EC; en función del algoritmo de firma utilizado. Es un archivo binario que contiene 2 elementos principales [JARSINT]: la firma digital del archivo JAR, generada con la clave privada del firmante, y el certificado, que adjunta la clave pública del firmante para ser utilizado por cualquiera que quiera verificar la integridad y la autoría del archivo JAR firmado.

[ DESCRIBIR PROCESO DE VERIFICACIÓN ??? ]

Antes de describir el procedimiento práctico para firmar aplicaciones Android, se definirá las 2 formas en que las aplicaciones son preparadas, en las cuales está involucrada la firma [IBMASEC]:
- Modo de depuración: cuando una aplicación está en etapa de desarrollo o pruebas no tiene mucha relevancia firmar una aplicación, por ello se firma con una clave privada y certificado conocidos, están hechos para ser usados en esta fase de la aplicación. El firmado en esta etapa se realiza automáticamente cuando se utiliza Android Studio, usa siempre la misma clave privada de depuración y el mismo certificado.
- Modo de publicación: cuando el proyecto se encuentra en la etapa de publicación, se debe generar una firma utilizando la clave privada del autor del software. En caso de no tener esta clave privada, se la genera (al igual que el certificado) con el uso de la herramienta keytool para luego firmar la aplicaciónes con jarsigner. Estas dos herramientas son heredadas del entorno Java y estan presentes en la IDE de Android Studio mediante asistentes paso-a-paso.

El proceso de firmado se puede entender con mayor claridad describiendo el procedimiento manual del firmado, en modo de publicación [KEYTOOL] [SIGNMAN]:
1) Si es la primera vez que se va a firmar una aplicación entonces se debe crear una keystore con una entrada (una clave privada y un certificado autofirmado). O de otro modo, se debe agregar una entrada a un keystore existente. En cualquiera de los 2 casos se ejecuta (si no existe la keystore, se crea automáticamente):
$ keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000
Donde:
	my-release-key.keystore es el nombre del archivo que representa al keystore.
	alias_name identifica a la nueva entrada (una clave privada y un certificado) que se agrega al keystore.
	RSA es el algoritmo que genera el par de claves.
	2048 es el tamaño de la clave.
	10000 es la cantidad de días de vigencia que va a tener la clave privada para firmar.
Nota: luego de ejecutar esta línea, se le pide al usuario que ingrese una contraseña nueva (o la contraseña del keystore existente) para el nuevo keystore y otra contraseña para proteger una clave privada que se genera dentro de este keystore. Además se exige el ingreso de los datos del sujeto del certificado como nombre, apellido, nombre de la unidad de organización, nombre de la organización, localidad, provincia y el código de 2 letras del país.
Si se quiere ver el contenido del keystore recién creado (la información de los certificados, entre otras cosas), se debe ejecutar:
$ keytool -list -v -keystore my-release-key.keystore
2) Compilar la aplicación en modo de publicación desde Android Studio, para obtener un archivo APK sin firmar (supóngase que ese archivo se va a llamar "my_application.apk"). Este paso no se va a detallar porque escapa al objetivo del ejemplo.
3) Se firma la aplicación.
$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name
Donde:
	SHA1withRSA especifica el algoritmo para obtener el valor de hash y el algoritmo para firmar.
	SHA1 especifica el algoritmo de la función de hash a usar con cada archivo que contiene un archivo JAR.
	my-release-key.keystore es el nombre del keystore generado en el paso 1.
	my_application.apk es el nombre de la aplicación no firmada creda en el paso 2.
	alias_name es el nombre del alias con el que se generó la firma en el paso 1.
4) Se usa el comando para verificar que la aplicación haya sido firmada correctamente.
$ jarsigner -verify -verbose -certs my_application.apk
Donde:
	my_application.apk, es el nombre de la aplicación firmada en el paso anterior.
5) Zipalign - Optimiza la forma en que un archivo APK es empaquetado. Lo que permite que el sistema operativo maneje la aplicación de una forma más eficiente, reduciendo el tiempo de ejecución y la cantidad de memoria consumida por la aplicación [WHATZIP].
	$ zipalign -v 4 my_application.apk my_aligned_application.apk

[OPCIONAL]
El firmado que realiza Android Studio cada vez que se corre o depura una aplicación Android se basa en el comando:
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name
-alias androiddebugkey
-keystore /the/path/debug.keystore
-storepass android
-keypass android
[http://stackoverflow.com/questions/16711233/signing-an-existing-apk-using-debug-keystore-generated-by-eclipse]

En Android se suelen firmar aplicaciones adjuntando el mismo certificado digital, éstos son motivos para firmar de esta forma [DEVSIGN]:
+ Permite actualizar: si se desea modificar la aplicación (por ejemplo, para corregir bugs o para agregar nueva funcionalidad), tendrá que ser firmada de vuelta y esta operación sólo podrá hacerla el que posea la clave privada; entonces, para que una aplicación se pueda actualizar, los desarrolladores deben conservar el mismo certificado, si se usa un certificado distinto, no se actualizará la aplicación porque será considerada otra aplicación distinta.
+ Se pueden compartir recursos: si se requiere que 2 aplicaciones compartan recursos, es un requisito indispensable que las mismas usen el mismo certificado. Además, para lograrlo se debe especificar la opción en el manifiesto que verifica los permisos en base a la firma. Cumpliendo con estas 2 condiciones, se puede compartir un ID de usuario (UID) con 2 o más aplicaciones y entre ellas van a poder acceder a sus recursos.
+ Obtener prestigio: una empresa o un desarrollador podría firmar todas sus aplicaciones con el mismo certificado para formar una reputación.
+ Modularidad: varias aplicaciones se pueden agrupar en un proceso si son firmadas con el mismo certificado y se habilita una configuración (en el archivo AndroidManifest.xml
), o sea que estas aplicaciones serán tratadas como una sola aplicación. Ésto posibilita trabajar de forma incremental agregando nuevos módulos (nuevas actualizaciones) independientes unas de otras.

3.3 Medidas de seguridad adicionales

En Android se pueden configurar ciertos mecanismos incorporados para mejorar la seguridad del dispositivo. Conviene realizar esta configuración cuando se inicia el equipo por primera vez. Los mecanismos que se van a presentar en esta parte vienen con el sistema operativo (no hace falta instalar nada), algunos de ellos son productos de Google, se pueden extender estas medidas de seguridad instalando aplicaciones de terceros, ésto se expondrá en el capítulo 5. Estos mecanismos se presentarán a continuación, en algunos casos se mostrarán configuraciones que se pueden hacer sobre ellos tomando como referencia el mapa de menús de un dispositivo (modelo "Moto G (2014)" de Motorola) con Android 5.0 "Lollipop".

3.3.1 Bloqueo de pantalla

El bloqueo de pantalla con clave es la medida más simple y es una de las primeras que se debe activar para evitar un eventual acceso no autorizado al smartphone.
Hay 3 métodos para bloquear la pantalla con clave, éstos son: a través de un pin (un número de al menos 4 dígitos), patrón (muestra una cuadrícula de 9 x 9 puntos en donde el usuario traza un camino que no repite puntos) o contraseña (una cadena de caracteres). Para acceder a esta configuración: el usuario se debe dirigir al menú principal, luego dirigirse al ítem "Configurar", entonces se debe ingresar al submenú "Seguridad", allí dentro se debe seleccionar el ítem "Bloqueo de pantalla".
En la elección de una clave y en el método de ingreso, hay más de una postura posible. Si consideramos la frecuencia con que se va a desbloquear el dispositivo, el método de PIN con una longitud razonable (5 dígitos, por ejemplo) es una buena opción. Si se considera lo ideal, se puede elegir el método por contraseña, con una clave alfanumérica fuerte. El patrón es el más sencillo de usar, aunque también es sencillo de adivinar para las personas que están alrededor del usuario que ven el mismo movimiento varias veces y también existe la posibilidad de adivinarlo con la observación de huellas dactilares en la pantalla; si se usa este método de ingreso de clave, es recomendable desactivar la visualización del trazo por la pantalla.
Existe una servicio adicional para algunos dispositivos con Android relacionado al bloqueo/desbloqueo del dispositivo, se llama "Smart Lock" [SMRTLCK]. La idea es facilitar el acceso al estado de desbloqueado del dispositivo, en función de determinados factores. Este servicio provee las siguientes prestaciones:
- Dispositivos de confianza: se puede utilizar un dispositivo (de confianza), como un reloj o un parlante, para mantener el teléfono desbloqueado cuando ese dispositivo está conectado por Bluetooth o NFC. Es posible que primero se deba desbloquear el teléfono de forma manual, pero luego cuando se conecte el dispositivo de confianza ya no se bloqueará.
- Lugares de confianza: esta aptitud se basa en la ubicación física del usuario como factor que determinará si el dispositivo se debe desbloquear o no; por lo general, estas ubicaciones son lugares como la casa del usuario y no el lugar de trabajo, es decir aquellos lugares donde no se necesita que el dispositivo esté bloqueado. Para facilitarle y posibilitarle el trabajo a este servicio, se necesita información de la ubicación geografica (el GPS debe estar activado) y una conexión a Internet. Este servicio se fija si las ubicaciones previamente guardadas (lugares confiables) por el usuario coinciden con la actual, si es así el dispositivo queda desbloqueado.
- Rostro de confianza: se refiere al reconocimiento facial que se lleva a cabo para que el dispositivo se desbloquee cada vez que se toca el botón de encendido y se enciende la pantalla bloqueada, previo al uso de esta característica se tendrá que guardar un rostro de confianza. Es una característica que mejora la interacción entre el usuario y el dispositivo, aunque es menos seguro que el uso de un PIN o contraseña como clave.
- Voz de confianza: hay una función que realiza búsquedas en Google en base a lo que se escucha por el micrófono del equipo, o sea reconoce una frase. Este servicio no está continuamente escuchando; entonces, para activarlo, el usuario tendrá que mencionar con su propia voz la frase "Ok google". Se puede aplicar el mismo mecanismo para desbloquear el dispositivo, con la diferencia que ahora se va a verificar el sonido de la voz para comprobar si corresponde a la del usuario y no será necesario que se ingrese la contraseña para ver los resultados de la búsqueda. Previamente se tendrá que guardar el registro de la voz del usuario.
- Detección del cuerpo humano: permite que el dispositivo permanezca desbloqueado cuando el usuario se lo lleva consigo, por ejemplo, en la mano, el bolsillo o el bolso. El acelerómetro incorporado mantendrá el dispositivo desbloqueado cuando detecte que el usuario lo está transportando. El teléfono se bloqueará automáticamente cuando detecte que otra persona lo está llevando. Dado que los datos del acelerómetro sobre la forma de caminar del usuario se guardarán en el dispositivo, asimismo el servicio podrá determinar que el dueño lo lleva encima.
Esta lista de prestaciones se la encuentra yendo al menú general, seleccionando "Configurar", luego desde ese menú elegir "Seguridad", finalmente se debe acceder al ítem "Smart Lock" que aparece en el listado de opciones que se muestra.

3.3.2 Añadir la información de contacto en la pantalla de bloqueo

Existe una función que es simple y que puede llegar a ser útil en caso de que el dispositivo se haya extraviado y lo haya encontrado algún individuo con intenciones de devolverlo a su dueño. La función consiste en mostrar información personal en la pantalla seleccionada por el usuario [INFOSCR], cuando el dispositivo esta bloqueado. Esta información puede ser un número de teléfono o un mail para ponerse en contacto con el dueño, pero se debe evitar mostrar información que comprometa su privacidad y seguridad.
Para agregar esta información, el usuario se debe dirigir al menú principal de aplicaciones, elegir "Configurar", luego en el menú que aparece se debe seleccionar "Seguridad", y finalmente se debe seleccionar "Datos del propietario" donde se puede escribir un texto arbitrario.

3.3.3 Backup de datos

Se pueden resguardar datos del dispositivo en la nube con 2 aplicaciones que vienen preinstaladas con Android: Google Fotos y Google Drive [APPSBAC]. También se pueden utilizar aplicaciones de terceros (tema que se tocará en el capítulo 5). En Google Fotos solo se pueden subir cualquier imágen que contenga el dispositivo, incluso se pueden retocar y aplicar efectos. En Google Drive se pueden subir archivos de cualquier tipo, tiene 15Gb de capacidad. Dado que con ambos se suben datos a la nube, se puede acceder a ellos desde cualquier PC (con el usuario y contraseña).
Desde la aplicación de Google Fotos se pueden sincronizar las imágenes del dispositivo con la nube, para lograrlo estos son los pasos a seguir [GOOFOTO]: el usuario debe ingresar a la aplicación, luego desde el menú general se debe elegir "Configuración", luego "Copia de seguridad y sincronización"; y desde acá se podrá activar la sincronización de los datos que maneja la aplicación (imágenes). Inmediatamente se iniciará la subida de imágenes a la nube, aquellas que no fueron subidas aún serán distinguidas con un ícono en particular. Concluyendo, esta función permite el almacenamiento de imágenes en la nube en sincronización con las que contiene el dispositivo, o sea que si se agregan o eliminan desde el dispositivo también lo hará en la nube.
Desde la aplicación de Google Drive se pueden gestionar archivos subidos en la nube y se pueden subir archivos desde un dispositivo [GOODRIV]; a diferencia de Google Fotos, en esta aplicación se pueden subir archivos de forma manual, no se pueden sincronizar automáticamente una o varias carpetas de un dispositivo directamente con la nube; en cambio, en la versión para PC/Mac de Google Drive se puede realizar este tipo de sincronizaciones [DRIVEPC].

3.3.4 Google Play

Una gran cantidad de malware proviene de orígenes desconocidos, por ejemplo, de marketplaces alternativos a Google Play. O sea, generalmente no conviene descargar aplicaciones de estos marketplaces porque el usuario no tiene forma de saber como se gestionan las aplicaciones disponibles y si éstas son confiables.
Android brinda cierta libertad en la forma en que se distribuyen aplicaciones, luego la instalación es un proceso directo, sencillo y rápido, no tiene que suponer ningún problema. Si el usuario instala aplicaciones que provienen de Google Play, cuenta con el respaldo de una barrera de seguridad llamada "Bouncer" que analiza las aplicaciones que se suben y las que ya estan subidas buscando malwares para detener su actividad, también examina las cuentas de usuarios en busca de actividades sospechosas para suspenderlas [BOUNCER]. Entonces, esta medida de seguridad (que no es infalible) disminuye las probabilidades de sufrir daños por una aplicación maliciosa, si usamos Google Play como fuente de aplicaciones.
Existe una opción en la configuración de Android, para que el sistema operativo solo acepte aplicaciones provenientes de Google Play [UNKSOUR], se puede activar de la siguiente manera: en el menú general se debe elegir "Configurar", luego en el menú que aparece se debe elegir "Seguridad", para que finalmente se pueda desactivar la casilla de "Fuentes desconocidas". Si el usuario se dispone de confiar en Google Play, esta medida le puede interesar. No obstante, esta opción viene desactivada por defecto, al menos para el modelo que se usó como referancia.
Google Play Services, que trabaja en conjunto con Google Play, es una aplicación que corre en segundo plano, se sincroniza con todo el sistema y posee una API para que los desarrolladores aprovechen los servicios que ofrece (que son muchos). Pero en cuestión de seguridad, que es lo que interesa en este punto, se puede encontrar dentro del repertorio de servicios algunas funciones que pueden ayudar; una se encarga de revisar la seguridad del sistema y envía avisos a Google en caso que alguna sea sospechosa, y la otra, se encarga de detener una aplicación en caso de que intente dañar el equipo.
Para activar estas opciones, el usuario se debe dirigir al menú principal, elegir "Configuraciones de Google", luego aparece un menú y se debe elegir el ítem "Seguridad", finalmente se encuentran las 2 opciones de configuración que interesan: "Buscar amenazas de Seguridad" y "Mejorar detección de aplicaciones perjudiciales" que sirven para realizar un control en busca de actividades sospechosas en el equipo y enviar información de las aplicaciones maliciosas a Google (en caso de encontrarlas) para contribuir en la mejora de este software, respectivamente. De hecho, en este menú hay otra opción que puede ayudar a mantener la privacidad de los datos del usuario, se puede activar las opciones de "Bloquear y borrar datos del dispositivo de forma remota", con lo cual se puede realizar las siguientes operaciones de forma remota (en casos excepcionales): borrar todos los datos y bloquear la pantalla.
Otro tema a resaltar con Google Play es la descarga automática de actualizaciones [AUTOUPD]. Por lo general, esta opción de configuración viene activada por defecto, al menos en el caso del smartphone que se toma como referencia. En el caso de que no esté activa la opción, se debe realizar lo siguiente: dentro de la aplicación de Google Play ir al menú general, ir a "Configuración", y finalmente elegir "Actualizar aplicaciones automáticamente" en donde aparecerán 3 opciones: no actualizar aplicaciones automáticamente, actualizar aplicaciones automáticamente solo por wifi o por una conexión a la red de datos del proveedor del celular (puede tener recargos). Para algunos usuarios puede resultar molesto que las actualizaciones se inicien automáticamente (y sorpresivamente) cuando éstas consumen un ancho de banda considerable, para ellos puede resultarle útil la opción de ser notificados solamente cuando surgen nuevas actualizaciones.

3.3.5 Administrador de Dispositivos de Android

En Android se puede usar otro complemento que forma parte de los productos de Google, llamado Administrador de Dispositivos de Android ("Android Device Manager"), un servicio integrado al sistema operativo. Permite localizar, bloquear o eliminar datos del smartphone de forma remota desde una computadora. No se debe instalar nada en el smartphone, solo se necesita una cuenta de Google. Con este servicio activado, si un smartphone es robado o perdido, el dueño podría encontrarlo y recuperarlo. Incluso si no se pudiera recuperar el smartphone, se pueden proteger los datos sensibles realizando un borrado de ellos de forma remota.
Este servicio permite tener control del smartphone desde una computadora (un enlace remoto) de la siguiente forma: el usuario ingresa a la cuenta Google asociada a su smartphone y se dirige al panel de control [PANLADM], en donde se encuentran las operaciones posibles:
- Se puede ubicar el lugar geográfico dónde se encuentra el smartphone, se lo muestra en un mapa a través de Google Maps.
- Se puede hacer sonar al smartphone.
- Se puede bloquear la pantalla del smartphone. Permite definir una contraseña para bloquear al smartphone remotamente. Cuando se activa, pide el ingreso de una contraseña (y su reingreso), un mensaje y un número de teléfono que se van a mostrar en la pantalla; cuando se confirman estos datos se bloquea el smartphone con una pantalla particular de color negro. Si previamente no se definió una clave que bloquee la pantalla desde el smartphone, se puede aprovechar esta característica, de lo contrario la contraseña suministrada será ignorada.
- Se pueden borrar datos del smartphone. Esto implica: un reestablecimiento al estado de fábrica, se eliminarán las aplicaciones, las fotos, la música y las configuraciones. Luego, el administrador de smartphones Android ya no funcionará. Esta acción no se puede deshacer. Es posible que no se pueda borrar el contenido de la tarjeta SD del smartphone. Si el smartphone no tiene conexión, se restablecerá al estado de fábrica cuando vuelva a estar conectado.
Desde el smartphone, si se desea activar este servicio, previamente se debe activar el GPS de la siguiente forma: ir al menú principal, donde se debe elegir "Configurar", luego del menú que aparece se debe seleccionar "Ubicación" en donde se puede pulsar una llave que activa esta característica del hardware. Luego, para activar el Administrador de Dispositivos de Android [ANDMOFF], se debe seguir el siguiente camino dentro de los menúes del smartphone: dentro del menú principal, elegir "Configución de Google", luego seleccionar "Seguridad", activar la llave en donde dice "Ubicar este dispositivo de forma remota" y también "Bloquear y borrar datos del dispositivo".

3.3.6 Seguridad en la red

3.3.6.1 Conexión de las aplicaciones

Android proporciona comunicaciones seguras a través de Internet para la navegación web, correo electrónico, mensajería instantánea y otras aplicaciones de Internet, basándose en los protocolos criptográficos como TLS (Transport Layer Security) y SSL (Secure Sockets Layer), incluyendo TLS v1.0, TLS v1.1, TLS v1.2 y SSL v3 [GOOUSER]. Éstos son los protocolos que usualmente se utilizan cuando se necesita encriptación en los datos que transitan de un host a otro. Por ejemplo, en los entornos de escritorio, todos los navegadores importantes soportan TLS [TLSWIKI].

3.3.6.2 Conexión WiFi

Android soporta conexiones inalámbricas encriptadas que respetan el protocolo WPA2-Enterprise (802.11i), el cual esta diseñado específicamente para redes empresariales. El soporte del protocolo WPA2-Enterprise usa encriptación AES-128, proporcionando a las empresas y a sus empleados un alto nivel de protección al enviar y recibir datos a través de la conexión Wi-Fi. Android soporta 802.1x EAPs (Extensible Authentication Protocols), incluyendo EAP-TLS, EAP-TTLS, PEAPv0, PEAPv1 y EAP-SIM  [GOOUSER].

3.3.6.3 Conexión con una VPN

Android soporta conexiones seguras con el uso de una VPN. La idea de una red VPN es conectarse a una red privada sobre una red pública como Internet, utilizando técnicas como tunneling y/o encriptación. Una VPN se podría establecer entre dos sistemas finales o entre dos organizaciones, entre varios sistemas finales dentro de una sola organización o entre varias organizaciones a través de Internet, entre aplicaciones individuales, o cualquier combinación de éstos. O sea, lo interesante de usar una VPN en las organizaciones es que una parte de las comunicaciones se vuelve "invisible" a los observadores ajenos a una organización, aprovechando al mismo tiempo la eficiencia de una infraestructura de comunicaciones común. Se suele usar una VPN por cuestiones económicas [CISCVPN].
Para configurar una conexión a una red VPN se debe ingresar al menú general de aplicaciones, elegir el ítem "Configurar", dentro del grupo denominado "Conexiones inalámbricas y redes" sleccionar "más", cuando aparece su submenú se debe elegir VPN. En esta sección aparecen las operaciones relacionadas con la gestión de VPNs (alta, baja, edición y conectar) [VPNANDR].

3.3.6.4 Conexión con un Proxy

El usuario tiene la posibilidad de conectarse a un servidor proxy. Un servidor proxy es una computadora que actúa como intermediario entre una red local (por ejemplo, todas las computadoras de una empresa) y una red de gran escala como Internet. Generalmente, los servidores proxy proveen un incremento en el rendimiento y en la seguridad. En algunos casos, monitorean el uso de la red externa [PROXYIU].
Un servidor proxy funciona interceptando conexiones entre el emisor y receptor. Todos los datos que entran, ingresan por un puerto y se reenvían al resto de la red a través de otro puerto. Al bloquear el acceso directo entre dos redes, los servidores proxy hacen que sea mucho más difícil para los hackers la obtención de direcciones internas y los detalles de una red privada.
Para poder configurar un proxy, el usuario debe seguir estos pasos: dentro del menú general, elegir "Configurar", luego aparece un menú del cual se debe seleccionar el ítem "Wi-FI", mantener apretado en una de las redes Wi-Fi que se listan para que aparezca un menú emergente; una vez allí, seleccionar "Modificar red", finalmente marcar el casillero "opciones avanzadas" para que se pueda ver la opción correspondiente al tipo de conexión proxy [PROXAND].

3.3.7 Multiusuario

En Android pueden haber varios perfiles de usuario (en Android, se llaman simplemente "usuarios"), tienen una configuración general propia, cada perfil guarda datos diferentes de las aplicaciones que instaló. En el uso del dispositivo, se puede usar uno de estos perfiles y la idea es que se puedan intercambiar explícitamente con un control de fácil acceso (que aparece en la parte superior de la pantalla). Una vez accedido a un perfil cualquiera, aparecerá la pantalla bloqueada (en caso de que se haya activado esta medida de seguridad). Para resumir, las características que provee esta funcionalidad son:
	- Un perfil de usuario puede correr en segundo plano cuando otro esta activo.
	- Los datos de un usuario estan siempre aislados de los otros usuarios.
Por último, Android tiene otra característica que puede ayudar a mejorar la seguridad y organizar los contenidos que generan los usuarios del dispositivo. Android implementa el concepto de usuario primario y usuario secundario [GOOUSER]:
	- Un usuario primario es el primer usuario agregado a un dispositivo. No se puede eliminar, excepto cuando se lleva al dispositivo al estado de fábrica. Este usuario también tiene privilegios especiales y configuraciones que son establecidas solamente por él. El usuario primario siempre se está ejecutando, incluso cuando otros están corriendo en primer plano.
	- Un usuario secundario puede ser cualquier usuario agregado al dispositivo, pero que no sea el usuario principal. Un usuario secundario puede ser eliminado por él mismo y por el usuario principal, pero no puede afectar a los otros usuarios de un dispositivo. Los usuarios secundarios pueden ejecutarse en segundo plano y seguir teniendo la conexión a red cuando se conectan, por ejemplo. Sin embargo, hay algunas restricciones en el acceso a los recursos; por ejemplo, cuando están corriendo en segundo plano no son capaces de mostrar la interfase del usuario o conectarse por Bluetooth. Los usuarios secundarios que corren en segundo plano son parados por el proceso del sistema, si el dispositivo requiere memoria adicional para las operaciones que esté realizando el usuario que esta corriendo en primer plano.

3.3.8 Encriptación del dispositivo

En Android se puede realizar una encriptación de disco completa (full disk encryption) [ENCRCEN], lo que quiere decir que todos los datos del usuario se pueden encriptar usando una clave de encriptación basada en el código de acceso o contraseña proporcionado para bloquear la pantalla, luego esta contraseña/clave se la pedirá cada vez que el dispositivo es encendido.
Cuando el dispositivo está encriptado, todos los datos del usuario que se vayan a crear, se cifran de forma automática antes de guardarse en el disco; asi mismo, en todas las lecturas futuras, se descifrarán los datos automáticamente antes de retornarle el poder al proceso que pidió la lectura. Este mecanismo puede servir como una protección adicional en caso de que el dispositivo se haya robado o perdido (y accedido por usuarios maliciosos). Además de ser recomendable para resguardar la seguridad, este mecanismo sirve para comprobar la integridad de los datos. Por otro lado, este mecanismo no tiene ningún efecto apreciable en el rendimiento, al menos esto sucede en los equipos más modernos.
En cuanto a la implementación del mecanismo, básicamente se puede mencionar que el algoritmo de encriptación es AES-128 [ANDENCR]. La llave maestra también es encriptada con AES-128 mediante llamadas a la librería OpenSSL adaptada al entorno Android, aunque los fabricantes del dispositivo pueden usar AES de 128 bits o más. El proyecto original de Android (AOSP) maneja la encriptación, por lo general, desde el almacenamiento interno, no así en el contenido de la tarjeta SD; aunque algunos fabricantes agregan una función de encriptación de la tarjeta SD, modificando el sistema operativo.
Previo a la realización de la encriptación [ENCDATA] se debe considerar estos 4 puntos: establecer una clave de bloqueo de pantalla (como previamente se describió), conectar el cargador al dispositivo, tener en cuenta que el proceso inicial llevará un tiempo (una hora o más) y finalmente, se debe considerar que si se interrumpe el proceso de encriptación se pueden perder datos (para disminuir las pérdidas se puede realizar un backup). Si no cumple alguna de las 2 primeras condiciones (si se está sin clave y sin cargador conectado), el sistema deniega el acceso al comando de encriptación.
Para proceder con la encriptación, el usuario se debe dirigir al menú principal, de ahí elegir el ítem "Configurar", dentro de sus opciones seleccionar "Seguridad"; finalmente, en esta instancia se debe seleccionar "Encriptar teléfono".
Luego de la encriptación, la clave se exigirá cada vez que se arranque el sistema. Ésto sirve para comprobar la integridad de los archivos. Se puede deshabilitar esta característica, pero no es recomendable.

[ OPCIONAL ]
Verificación de 2 pasos
-----------------------

Esta medida de seguridad forma parte del grupo de servicios de Google. Muchas de las aplicaciones que vienen preinstaladas en los smartphones con Android pertenecen a Google y para poder utilizarlas, se exige el ingreso de los datos de una cuenta de Google, de lo contrario no se va a poder utilizar la aplicación. Este mecanismo de las cuentas de Google, se llama "Verificación en 2 pasos" y sirve para proteger la cuenta Google que esté relacionada al dispositivo [GOO2STEP].

Ideas principales [GOO2STEP]:
- La verificación en dos pasos te protegerá de usuarios malintencionados incluso en el caso de que tengan tu contraseña.
- La mayoría de los usuarios solo tienen una capa de seguridad, su contraseña, para proteger su cuenta. Con la verificación en dos pasos, si un hacker consigue franquear la capa de seguridad de tu contraseña, todavía necesitará tu teléfono o tu llave de seguridad para acceder a tu cuenta.

La verificación en dos pasos es uno de los mejores consejos de seguridad. Además de poner la contraseña en las aplicaciones, con este método hay que añadir un código que nos envían a través de SMS. Sin este mensaje nadie podrá entrar en nuestra cuenta, ni siquiera aunque sepa la contraseña. Es un método algo engorroso pero vital para cubrirnos de cualquier riesgo. No solo Google está introduciendo este sistema, la mayoría de grandes empresas también lo ha hecho. Para activarlo tendremos que ir a los ajustes de Google.

[GOO2STEP] [ https://www.google.es/intl/es/landing/2step/ ]
[ http://www.elandroidelibre.com/2014/12/10-sencillos-consejos-para-mejorar-la-seguridad-de-tu-android.html ]

[ OPCIONAL ]
Seguridad de las aplicaciones [externa al SO]
---------------------------------------------
---------------------------------------------

Las restricciones para preservar la seguridad en Android se manifiestan de diferentes formas. En algunos casos, cuando se trata con ciertas funciones delicadas del sistema, existe cierta restricción intencionada en el acceso con la omisión de APIs (por ejemplo no hay una API para Android para manipular directamente la tarjeta SIM). Por otro lado, como ya se mencionó, existe la separación de roles con respecto a los recursos (generalmente archivos) que provee una medida de seguridad, por ejemplo cuando se distinguen a los usuarios que acceden a un archivo (se lo puede identificar como dueño, miembro de un grupo o cualquier otro usuario), ésta es una característica heredada de Linux. En otros casos, ciertas APIs protegidas pueden ser usadas por aplicaciones confiables, emplean un mecanismo de seguridad conocido como permiso; estas APIs poseen limitaciones que se pueden alterar explícitamente con la finalidad de proteger servicios valiosos del dispositivo como las funciones de la cámara, los datos de la ubicación (GPS), funciones de Bluetooth, funciones de telefonía, funciones relacionadas a la mensajería del tipo SMS/MMS y las conexiones de datos o redes.

[Fuente: http://source.android.com/tech/security/index.html]

[ OPCIONAL ]
Gogle Play
-----------

Fuente:
https://en.wikipedia.org/wiki/Google_Play#Application_security

[ OPCIONAL ]
Fragmentación
-------------

A la fecha de hoy, 6 de Diciembre del 2012, Android es la plataforma móvil más popular: tiene una gran comunidad de desarrolladores programando aplicaciones con el fin de extender la funcionalidad de los dispositivos que soportan Android. Los desarrolladores pueden usar Google Play como medio de propagación para difundir sus aplicaciones, este repositorio alberga a más de 600000 aplicaciones. Según el libro titulado "Forense en Android", Google Play se lo puede comparar con la propuesta similar de Apple llamada App Store, salvo que esta última se distingue por su control estricto en el proceso de revisión de aplicaciones al momento de publicar una aplicación; no sucede así con Google Play, que tiene requisitos mas ligeros, aunque tiene la capacidad para inhabilitar a los desarrolladores que lleguen a publicar sofware malicioso y eliminar sus aplicaciones. [ANDACT]

El siguiente cuadro se basa en la cantidad de accesos de dispositivos Android a Google Play según la versión, en un período de 14 días (del 20 de Noviembre al 3 de Diciembre del 2012 inclusive). [DASHBO]

Version			Nombre en código	Versión de la API		Distribución
1.5				Cupcake				3						0.1%
1.6				Donut				4						0.3%
2.1				Eclair				7						2.7%
2.2				Froyo				8						10.3%
2.3 - 2.3.2		Gingerbread			9						0.2%
2.3.3 - 2.3.7						10						50.6%
3.1				Honeycomb			12						0.4%
3.2									13						1.2%
4.0.3 - 4.0.4	Ice Cream Sandwich	15						27.5%
4.1				Jelly Bean			16						5.9%
4.2									17						0.8%

[DASHBO] [Fuente: http://developer.android.com/about/dashboards/index.html]
[ANDACT] [Fuente: http://es.wikipedia.org/wiki/Android] (sección "Historial de actualizaciones")

[OPCIONAL]
Mejoras en la administración de la memoria (hecho el 19/02/2013)

ASLR (address space layout randomization) es un mecanismo de seguridad informático que consiste en la disposición aleatoria de las direcciones de las áreas claves de datos como la base del ejecutable, la dirección de las bibliotecas, la heap y el stack, que están dentro del espacio de direcciones de un proceso. De esta forma, este mecanismo obstruye algunos tipos de ataques de seguridad haciendo mas difícil la predicción de las direcciones destino para un atacante.
La efectividad esta basada en la baja posibilidad de un atacante en adivinar las ubicaciones de las áreas aleatoriamente colocadas. A medida que se aumenta el espacio de búsqueda (aumentando el área de memoria virtual), se incrementa la seguridad. También se puede reducir el período durante el cual se produce la aleatorización para mejorar la efectividad, aunque generalmente este período se reduce lo máximo posible, entonces la mayoría de los sistemas deben optar por la primer opción.
El proyecto PaX fue el primero en emplear el término "ASLR", publicó el primer diseño e implementación de ASLR en julio del 2001, como un patch para Linux que es muy popular. Este proyecto sigue siendo la aplicación más completa, que en octubre del 2002 también proporcionó la asignación al azar en la pila del núcleo. OpenBSD se volvió en el primer sistema operativo de primera línea en proveer un soporte parcial de ASLR y terminó de incorporarlo en el año 2008. A partir de la versión 4.0 (conocida como "Ice Cream Sandwich"), Android introdujo ASLR para ayudar a proteger al sistema y a las aplicaciones de terceros de los exploits que aprovechan las imperfecciones en la administración de memoria; Apple lo introdujo en la versión 4.3 de iOS.

[Fuente: http://en.wikipedia.org/wiki/Address_space_layout_randomization#Android]
[Fuente: http://source.android.com/tech/security/index.html]

PIC (position-independent code) es una porción de código máquina que si se ubica en algún lugar de la memoria primaria se ejecuta correctamente independientemente de su dirección absoluta. PIC es comunmente usada para las bibliotecas compartidas, de modo que el mismo código de la biblioteca puede ser cargado en una ubicación en cada espacio de direcciones de programa en el que no se superponen otros usos de la memoria (por ejemplo, otras bibliotecas compartidas). PIE (Position-independent executables) tiene sus bases en PIC, pero en este caso, los fragmentos de código son binarios ejecutables que son completamente independientes del código. Los binarios PIE son usados en algunas distribuciones Linux enfocadas en la seguridad, que permite la asignación aleatoria de direcciones de memoria para evitar que los atacantes averigüen donde está el código ejecutable usando exploits que se basan en conocer el desplazamiento del código ejecutable en el binario.
En Android fue incorporado a partir de la versión 4.1.

[Fuente: http://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables]
[Fuente: http://source.android.com/tech/security/index.html]

El bit NX (deriva de "Never eXecute") es una tecnología empleada por las CPUs que separa áreas de memoria para que sean usadas para almacenar código o datos de forma exclusiva. Un sistema operativo con soporte para el bit NX puede marcar ciertas áreas de memoria como "no ejecutable". Entonces, el procesador denegará la ejecución de cualquier código que resida en estas áreas de memoria. La técnica general, conocida como "protección de espacio ejecutable", es usada para evitar que ciertos tipos de programas maliciosos tomen el control del sistema insertando su código dentro de otra área de datos del programa y corriendo su propio código desde adentro de esta sección; esto es conocido como un ataque "buffer overflow". Por ejemplo, Intel implanta esta característica como el bit XD (deriva de "eXecute Disable"), AMD usa el nombre de Enhanced Virus Protectiony, la arquitectura ARM hace referencia a esta propiedad como XN (eXecute Never) que fue introducida en ARM v6. A partir de la versión 2.3 de Android y posteriores, el hardware que lo soporta tiene páginas no ejecutables por defecto, evitando la ejecución del stack y la heap.

[Fuente: http://en.wikipedia.org/wiki/NX_bit]
