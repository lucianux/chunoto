Capítulo 3

Seguridad en Android

3.1 Objetivo

El objetivo general del capítulo es mostrar qué herramientas incorpora Android para defender la seguridad del usuario.
Concretamente, se explica el modelo de seguridad que provee Android y se describen los mecanismos adicionales que se emplean para mitigar riesgos. La primer parte se enfoca en 3 pilares: el kernel de Android, el sistema de permisos y el firmado digital de aplicaciones. En la segunda parte se describen las herramientas adicionales.

3.2 Modelo de seguridad

Android utiliza 2 modelos de permisos separados en capas que cooperan para alcanzar un objetivo compartido. Por un lado, en el nivel más bajo hay un kernel de Linux modificado que implementa los permisos basándose en un modelo "sandbox", el cual es transparente al usuario. Por otro lado, en la capa donde se encuentran las apps que interactuan con el framework de Android, el nivel mas alto de la pila de capas, se encuentra el segundo modelo. Este modelo es visible por los usuarios cuando ellos estan por instalar apps y pueden ver una lista de permisos correspondiente a una app. Esta lista es definida por el autor de la app y describe las aptitudes que necesita la app por parte del sistema.

3.2.1 Kernel de linux

Dado que el kernel de Android esta basado en el kernel de Linux, el cual es bastante maduro en materia de seguridad, le atribuye a Android las siguientes características que luego se describirán [SECKERN]:
.Aislación de procesos (modelo Sandbox).
.Mecanismo extensible para un IPC confiable (Binder).
.Un modelo de permisos basado en el usuario (uso de UID).
.Aislación de los recursos que pertenecen a un usuario (permisos en los archivos del filesystem).
Primero se va a revisar el modelo de seguridad básico en Linux y luego se verá de que forma se usa este modelo en Android.
En el contexto de la seguridad en Linux, se utilizan 2 conceptos importantes en relación a los usuarios: UID y GID. El UID es un identificador que se le asigna a cada usuario. El GID es un identificador que se le asigna a cada grupo de usuarios. Por otro lado, cada recurso tiene asignado un conjunto de permisos, por lo general, un recurso es un archivo. Los recursos tienen asignados 3 grupos de permisos basados en el usuario: un dueño, un grupo y el resto de los usuarios; cada grupo de permisos consta de los siguientes permisos basados en el recurso: lectura, escritura y ejecución (permite que el archivo sea tratado como un código ejecutable). Todos estos conceptos juntos persiguen un objetivo: evitar el acceso de cualquier aplicación a los datos, procesos y espacio de memoria ajenos a ella. Asimismo, se realiza una agrupación de los recursos por cada aplicación, cada miembro del grupo de recursos tiene asignado un UID como dueño [LINPERM].
En Android se aprovecha esta característica. A cada app instalada se le asigna un UID, con lo cual esta app corre bajo ese usuario (UID) en un proceso separado y todos los datos que se van almacenando serán propiedad de este UID (se les asignará este UID como dueño), ya sea un archivo, una base de datos u otro recurso. Se aprovecha el concepto de usuario único de Linux para aplicar la aislación de apps en Android. Por defecto, se aplica un régimen de aislación estricto para todas las apps, es decir que las apps no pueden interactuar entre sí a menos que se definan configuraciones adicionales, y lo mismo pasa con el acceso a las funciones del sistema operativo. Concluyendo con un ejemplo, si la app A intenta hacer algo malicioso como leer datos de la app B sin su consentimiento o hacer llamadas teléfonicas sin los permisos correspondientes, entonces el sistema operativo protegererá a la app B o denegará la realización de la llamada, porque la app A no tiene los privilegios de usuario debidos. Esta aislación y asignación de UID a procesos es lo que forma el modelo de Sandbox de apps a nivel de kernel.
El modelo Sandbox es simple, auditable y maduro, dado que en los sistemas basados en Unix hace mucho que se lo viene utilizando. Debido a que el modelo Sandbox se aplica a nivel del kernel, el mismo se extiende a las capas superiores. Para cada proceso, este modelo se emplea de la misma forma y con el mismo grado de seguridad. Como cualquier medida de seguridad, este modelo no es infalible, pero para evadirlo (en un dispositivo configurado apropiadamente) se necesita corromper la seguridad del kernel de Linux. El modelo Sandbox modera las catástrofes originadas por la corrupción de memoria, limitando los efectos a un contexto particular de un proceso y no al resto del sistema, este problema pasa cuando los contenidos de una ubicación de memoria son modificados involuntariamente debido a errores de programación.
En el Filesystem también se aplica el modelo de seguridad sandbox para prevenir que cada app acceda a los archivos de cualquier otra (que tenga distinto UID). Cada app guarda sus archivos en una ruta del estilo /data/data/{app_name} , en donde {app_name} es el nombre de la app, entonces el sistema configura este directorio de la siguiente forma: sólo se establecen los permisos del dueño, con el UID de la app; ningún otro UID (app) va a tener acceso porque ni los permisos del grupo, ni los permisos globales son definidos. Cuando la app cree nuevos archivos, sus permisos se definirán de la misma forma. Por ejemplo, ésto sucede dentro del directorio /data/data/{app_name}/files, en donde se van creando archivos durante la instalación y ejecución de la app. Sin embargo, se puede programar la app para que los archivos que se van creando puedan ser accedidos por otras, ésto se logra alterando los permisos que vienen por defecto. O dicho de otra forma, cualquier app que es configurada para correr con el mismo UID de otra app puede acceder a sus archivos; generalmente ésto se realiza sólo si se necesita compartir recursos y sucede con todas las apps originadas por el mismo desarrollador; cualquier app nueva que comparta el UID con una app ya instalada (y con la definición de algunas configuraciones adicionales), tendrá control total con los archivos de la app asentada [APPSECU].

3.2.2 Permisos

En el archivo de configuración de una app hay una lista de permisos, la cual sirve para definir explícitamente los accesos que va a tener la app a recursos y funciones del sistema (por defecto, Android no otorga ningún permiso), esta lista la define el autor de la app en un archivo llamado manifiesto ("AndroidManifest.xml"). Para el usuario de app, estos permisos advierten de las operaciones que son potencialmente peligrosas y que se llevarán a cabo una vez que la app sea instalada.
El modelo de solicitud de permisos se acciona justo antes de instalar una app, en ese instante el usuario deberá leer y aceptar (o rechazar) la lista de permisos; cuya aprobación no es individual o parcial sino total, por lo tanto sólo hay 2 alternativas: o se aceptan todos o ninguno de los permisos de una app, lo que produce la continuación o la cancelación de la instalación, respectivamente. Una vez que los permisos son otorgados, el sistema no notifica al usuario otra vez que los permisos fueron concedidos, esto se realiza así para evitar confusiones y mejorar la experiencia del usuario, en vez de proveer confirmaciones reiteradas que perjudican la interacción con el dispositivo. Los permisos son eliminados si una app es desinstalada, entonces en una subsecuente reinstalación se preguntará nuevamente por los permisos. El usuario tiene la posibilidad de ver los permisos otorgados a las apps previamente instaladas, están dentro de las propiedades de la app. En el caso de que una app intente usar una función sensible que no ha sido declarada en el manifiesto como permiso, generalmente produce una excepción de seguridad denominada "SecurityException" [SECPERM].
Hay 2 tipos de permisos: los permisos por defecto que trae el sistema y los permisos definidos por la app.
Este modelo tiene 2 ventajas principales sobre los modelos más tradicionales [SECOVER]. Primero, un usuario puede ver todas las acciones riesgosas que sería capaz de hacer la app antes de ser instalada y además se puede comprobar si la lista de permisos es coherente con respecto al propósito de la app antes de aceptarla, si coinciden con sus necesidades y espectativas. Por ejemplo, un usuario que descarga un juego que corre completamente de forma local (sin la necesidad de acceder a una red) vé que pide permisos para acceder a los mensajes SMS, hacer llamadas telefónicas y obtener acceso completo a Internet, lo cual no tiene fundamento y probablemente el usuario decidirá abortar la instalación. También es importante destacar que en el proceso de revisión de permisos, el usuario aún no ha establecido un compromiso mental o financiero con la app y se puede comparar fácilmente con otras apps alternativas.
Segundo, este modelo de permisos permite la contención de un ataque de una app maliciosa sobre otras apps genuinas y permite limitar el daño que pueda llegar a realizar una app maliciosa en función de los permisos concedidos. Por ejemplo, existen ciertas apps que tienen errores de programación, y en muchos casos, estos errores le permiten a los delicuentes expertos en informática dominar a la app que está corriendo y provocar que su propio código arbitrario corra en el mismo contexto que la app comprometida; en Android, una app expuesta ejecutará el código arbitrario del atacante con los privilegios que le fueron concedidos, ergo sus acciones serán circunscriptas a los permisos que aquella app ha declarado y se le han otorgado.
Mas allá de las ventajas de los permisos, uno se puede preguntar: ¿Los usuarios aprobarán cualquier conjunto de permisos pertenecientes a una app determinada ó ellos prestarán atención lo que contiene la lista que ellos deben aceptar para la instalación? El modelo de permisos sólo es válido si los usuarios son conscientes de lo que hacen. Primordialmente, no hay una forma para forzar a un usuario a que efectivamente entienda lo que esta aceptando. Debido a esta cuestión, las descripciones para los permisos usualmente son cortas y fáciles de entender.

3.2.3 Firmado digital

Todas las apps, incluyendo las del sistema, deben ser firmadas con un certificado digital que identifique a su autor. Un certificado es un archivo que encapsula los datos de la persona (o entidad) y la clave pública, estos valores son declarados con el aval de una Firma que es difícil de falsificar (sin la clave privada); esta Firma se adjunta en el archivo. La clave pública es un número largo que sirve para verificar la Firma. En cambio, la clave privada es un archivo que contiene otro número largo que sirve para generar la Firma y esta protegida con una contraseña, además se sugiere almacenarla en un lugar secreto, donde nadie tenga acceso excepto el propietario (generalmente, el desarrollador). Ambas claves son generadas con la misma herramienta. La Firma se procesa en base a algún dato del archivo a firmar (por lo general se usa una función de hash que usa un archivo como entrada, se la suele llamar fingerprint y devuelve una cadena de caracteres de longitud fija); este archivo y el certificado forman la firma digital [QUEESSE] [SISMODE].
Es habitual que un certificado digital sea firmado por una autoridad de certificación, sin embargo en Android esto no es necesario; de hecho, frecuentemente las apps de Android usan certificados auto-firmados (el mismo desarrollador puede generar el certificado).
Los siguientes motivos son posibles razones para firmar una app con un certificado digital:
+ Se firman las apps como medida de seguridad y como requisito de garantía: garantiza que sólo la entidad propietaria de la clave privada de la firma pueda producir un certificado digital válido para sus apps.
+ Proporciona integridad: significa que el certificado digital garantiza que el paquete de instalación de la app (archivo con extensión .apk) no ha sido alterado.
+ Proporciona autenticidad: significa que los datos vienen de quien afirma haber creado y firmado. De esta forma, sólo los autores / dueños de la app puedan modificarla y actualizarla.
+ Si no se hace, la app será rechazada cuando se la intente instalar en algún dispositivo con Android. Ésto es debido a que el paquete de instalación de la app (archivo .apk) será verificado mediante el Administrador de Paquetes (Package Manager) para comprobar si ha sido correctamente firmado con un certificado digital incluído en este archivo.
+ Si se desea publicar la app en Google Play, es un requisito indispensable que la app esté firmada. Si no se hace, la app será rechazada por este repositorio.
Los siguientes motivos son posibles razones para firmar apps con el mismo certificado:
+ Si se desea modificar la app (por ejemplo, para corregir bugs o para agregar nueva funcionalidad), tendrá que ser firmada de vuelta y esta operación solo podra hacerla el propietario de la app, o el que posea la clave privada cuando se firmó la primera vez. Entonces cuando las apps se actualizan, los desarrolladores deberían mantener el mismo certificado para que los usuarios puedan actualizarlas con transparencia.
+ Se puede compartir recursos: si se quiere que 2 apps compartan recursos, es un requisito necesario que las mismas el mismo certificado. Además, para lograrlo se debe especificar la opción en el manifiesto que verifica los permisos en base a la firma. Con estos 2 requisitos, se puede compartir un ID de usuario (UID) con 2 o más apps.
+ Un desarrollador podría firmar todas sus apps con el mismo certificado para formar una reputación aceptable.
+ Otro motivo es que en Android se permite el desarrollo de apps por módulos de forma tal que los usuarios puedan actualizar cada uno de estos módulos de forma independiente si es necesario.
En cuanto a la práctica, hay algunas cuestiones que se deben mencionar. Cuando la app está en etapa de desarrollo, no tiene mucha relevancia firmar una app, por lo cual se acude a usar una firma conocida y hecha especialmente para el proceso de desarrollo y pruebas. En cambio, cuando el proyecto se encuentra en la etapa de publicación, se usa un signado propio, que en caso de no tener uno se genera con una herramienta llamada Keytool y otra llamada Jarsigner, ambas heredadas del entorno Java, que son provistas en el entorno de desarrollo que suministra Android; ergo, la clave privada efectivamente puede ser generada por el mismo desarrollador sin necesidad de emplear la certificación de terceros para que validen la clave.
El proceso de firmado se puede entender con mayor claridad describiendo el procedimiento manual [KEYTOOL] [SIGNMAN]:
1) Se usa el comando para generar una keystore, que es un almacén de claves privadas en donde se encuentran los certificados pertenecientes a un desarrollador. Si es la primera vez que se va a firmar una aplicación entonces se debe crear una keystore.
	$ keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000
	Donde:
		my-release-key.keystore, es el nombre del archivo que se va a generar que contiene certificados, es un nombre que lo elige el usuario.
		alias_name, identifica a una nueva clave privada que se agrega al keystore, es un nombre que lo elige el usuario.
		Notas:
		- Luego de ejecutar esta línea, se le pide al usuario contraseñas para el keystore y la clave privada dentro de este keystore; además de los datos de la entidad que certifica (generalmente, lo hace el desarrollador) como nombre, apellido, nombre de la unidad de organización, nombre de la organización, localidad, provincia, país (código de 2 letras).
		- En este caso, el keystore generado contiene una sola clave privada, válida por 10000 días.
2) Compilar la app en modo "release" para obtener un archivo APK sin firmar (suponiendo que ese archivo se llame "my_application.apk"), lo cual se puede realizar desde la IDE. Este paso no se va a explicar porque escapa a los fines del ejemplo.
3) Se usa el comando para firmar la app.
	$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore my_application.apk alias_name
	Donde:
		my-release-key.keystore, es el nombre del archivo generado en el paso 1.
		my_application.apk es el nombre de la aplicación no firmada creda en el paso 2.
		alias_name, es el nombre del alias con el que se generó la firma en el paso 1.
4) Se usa el comando para verificar que la app haya sido firmada correctamente.
	$ jarsigner verify -verbose -certs my_application.apk
	Donde:
		my_application.apk, es el nombre del paquete del paso anterior.
5) Zipalign - Optimiza la app para que consuma menos RAM.
	$ zipalign -v 4 my_application.apk my_aligned_application.apk

3.3 Medidas de seguridad adicionales

En Android se pueden configurar ciertos mecanismos incorporados para mejorar la seguridad del dispositivo. Conviene realizar esta configuración cuando se inicia el equipo por primera vez. Los mecanismos que se van a presentar en esta parte vienen con el sistema operativo (no hace falta instalar nada), algunos de ellos son productos de Google, se pueden extender estas medidas de seguridad instalando apps de terceros, ésto se expondrá en el capítulo 5. Estos mecanismos se presentarán a continuación, en algunos casos se mostrarán configuraciones que se pueden hacer sobre ellos tomando como referencia el mapa de menús de un dispositivo (modelo "Moto G (2014)" de Motorola) con Android 5.0 "Lollipop".

3.3.1 Bloqueo de pantalla

El bloqueo de pantalla con clave es la medida más simple y es una de las primeras que se debe activar para evitar un eventual acceso no autorizado al smartphone.
Hay 3 métodos para bloquear la pantalla con clave, éstos son: a través de un pin (un número de al menos 4 dígitos), patrón (muestra una cuadrícula de 9 x 9 puntos en donde el usuario traza un camino que no repite puntos) o contraseña (una cadena de caracteres). Para acceder a esta configuración: el usuario se debe dirigir al menú principal, luego dirigirse al ítem "Configurar", entonces se debe ingresar al submenú "Seguridad", allí dentro se debe seleccionar el ítem "Bloqueo de pantalla".
En la elección de una clave y en el método de ingreso, hay más de una postura posible. Si consideramos la frecuencia con que se va a desbloquear el dispositivo, el método de PIN con una longitud razonable (5 dígitos, por ejemplo) es una buena opción. Si se considera lo ideal, se puede elegir el método por contraseña, con una clave alfanumérica fuerte. El patrón es el más sencillo de usar, aunque también es sencillo de adivinar para las personas que están alrededor del usuario que ven el mismo movimiento varias veces y también existe la posibilidad de adivinarlo con la observación de huellas dactilares en la pantalla; si se usa este método de ingreso de clave, es recomendable desactivar la visualización del trazo por la pantalla.
Existe una servicio adicional para algunos dispositivos con Android relacionado al bloqueo/desbloqueo del dispositivo, se llama "Smart Lock" [SMRTLCK]. La idea es facilitar el acceso al estado de desbloqueado del dispositivo, en función de determinados factores. Este servicio provee las siguientes prestaciones:
- Dispositivos de confianza: se puede utilizar un dispositivo (de confianza), como un reloj o un parlante, para mantener el teléfono desbloqueado cuando ese dispositivo está conectado por Bluetooth o NFC. Es posible que primero se deba desbloquear el teléfono de forma manual, pero luego cuando se conecte el dispositivo de confianza ya no se bloqueará.
- Lugares de confianza: esta aptitud se basa en la ubicación física del usuario como factor que determinará si el dispositivo se debe desbloquear o no; por lo general, estas ubicaciones son lugares como la casa del usuario y no el lugar de trabajo, es decir aquellos lugares donde no se necesita que el dispositivo esté bloqueado. Para facilitarle y posibilitarle el trabajo a este servicio, se necesita información de la ubicación geografica (el GPS debe estar activado) y una conexión a Internet. Este servicio se fija si las ubicaciones previamente guardadas (lugares confiables) por el usuario coinciden con la actual, si es así el dispositivo queda desbloqueado.
- Rostro de confianza: se refiere al reconocimiento facial que se lleva a cabo para que el dispositivo se desbloquee cada vez que se toca el botón de encendido y se enciende la pantalla bloqueada, previo al uso de esta característica se tendrá que guardar un rostro de confianza. Es una característica que mejora la interacción entre el usuario y el dispositivo, aunque es menos seguro que el uso de un PIN o contraseña como clave.
- Voz de confianza: hay una función que realiza búsquedas en Google en base a lo que se escucha por el micrófono del equipo, o sea reconoce una frase. Este servicio no está continuamente escuchando; entonces, para activarlo, el usuario tendrá que mencionar con su propia voz la frase "Ok google". Se puede aplicar el mismo mecanismo para desbloquear el dispositivo, con la diferencia que ahora se va a verificar el sonido de la voz para comprobar si corresponde a la del usuario y no será necesario que se ingrese la contraseña para ver los resultados de la búsqueda. Previamente se tendrá que guardar el registro de la voz del usuario.
- Detección del cuerpo humano: permite que el dispositivo permanezca desbloqueado cuando el usuario se lo lleva consigo, por ejemplo, en la mano, el bolsillo o el bolso. El acelerómetro incorporado mantendrá el dispositivo desbloqueado cuando detecte que el usuario lo está transportando. El teléfono se bloqueará automáticamente cuando detecte que otra persona lo está llevando. Dado que los datos del acelerómetro sobre la forma de caminar del usuario se guardarán en el dispositivo, asimismo el servicio podrá determinar que el dueño lo lleva encima.
Esta lista de prestaciones se la encuentra yendo al menú general, seleccionando "Configurar", luego desde ese menú elegir "Seguridad", finalmente se debe acceder al ítem "Smart Lock" que aparece en el listado de opciones que se muestra.

3.3.2 Añadir la información de contacto en la pantalla de bloqueo

Existe una función que es simple y que puede llegar a ser útil en caso de que el dispositivo se haya extraviado y lo haya encontrado algún individuo con intenciones de devolverlo a su dueño. La función consiste en mostrar información personal en la pantalla seleccionada por el usuario [INFOSCR], cuando el dispositivo esta bloqueado. Esta información puede ser un número de teléfono o un mail para ponerse en contacto con el dueño, pero se debe evitar mostrar información que comprometa su privacidad y seguridad.
Para agregar esta información, el usuario se debe dirigir al menú principal de apps, elegir "Configurar", luego en el menú que aparece se debe seleccionar "Seguridad", y finalmente se debe seleccionar "Datos del propietario" donde se puede escribir un texto arbitrario.

3.3.3 Backup de datos

Se pueden resguardar datos del dispositivo en la nube con 2 apps que vienen preinstaladas con Android: Google Fotos y Google Drive [APPSBAC]. También se pueden utilizar apps de terceros (tema que se tocará en el capítulo 5). En Google Fotos solo se pueden subir cualquier imágen que contenga el dispositivo, incluso se pueden retocar y aplicar efectos. En Google Drive se pueden subir archivos de cualquier tipo, tiene 15Gb de capacidad. Dado que con ambos se suben datos a la nube, se puede acceder a ellos desde cualquier PC (con el usuario y contraseña).
Desde la app de Google Fotos se pueden sincronizar las imágenes del dispositivo con la nube, para lograrlo estos son los pasos a seguir [GOOFOTO]: el usuario debe ingresar a la app, luego desde el menú general se debe elegir "Configuración", luego "Copia de seguridad y sincronización"; y desde acá se podrá activar la sincronización de los datos que maneja la app (imágenes). Inmediatamente se iniciará la subida de imágenes a la nube, aquellas que no fueron subidas aún serán distinguidas con un ícono en particular. Concluyendo, esta función permite el almacenamiento de imágenes en la nube en sincronización con las que contiene el dispositivo, o sea que si se agregan o eliminan desde el dispositivo también lo hará en la nube.
Desde la app de Google Drive se pueden gestionar archivos subidos en la nube y se pueden subir archivos desde un dispositivo [GOODRIV]; a diferencia de Google Fotos, en esta app se pueden subir archivos de forma manual, no se pueden sincronizar automáticamente una o varias carpetas de un dispositivo directamente con la nube; en cambio, en la versión para PC/Mac de Google Drive se puede realizar este tipo de sincronizaciones [DRIVEPC].

3.3.4 Google Play

Una gran cantidad de malware proviene de orígenes desconocidos, por ejemplo, de marketplaces alternativos a Google Play. O sea, generalmente no conviene descargar apps de estos marketplaces porque el usuario no tiene forma de saber como se gestionan las apps disponibles y si éstas son confiables.
Android brinda cierta libertad en la forma en que se distribuyen apps, luego la instalación es un proceso directo, sencillo y rápido, no tiene que suponer ningún problema. Si el usuario instala apps que provienen de Google Play, cuenta con el respaldo de una barrera de seguridad llamada "Bouncer" que analiza las apps que se suben y las que ya estan subidas buscando malwares para detener su actividad, también examina las cuentas de usuarios en busca de actividades sospechosas para suspenderlas [BOUNCER]. Entonces, esta medida de seguridad (que no es infalible) disminuye las probabilidades de sufrir daños por una app maliciosa, si usamos Google Play como fuente de apps.
Existe una opción en la configuración de Android, para que el sistema operativo solo acepte apps provenientes de Google Play [UNKSOUR], se puede activar de la siguiente manera: en el menú general se debe elegir "Configurar", luego en el menú que aparece se debe elegir "Seguridad", para que finalmente se pueda desactivar la casilla de "Fuentes desconocidas". Si el usuario se dispone de confiar en Google Play, esta medida le puede interesar. No obstante, esta opción viene desactivada por defecto, al menos para el modelo que se usó como referancia.
Google Play Services, que trabaja en conjunto con Google Play, es una app que corre en segundo plano, se sincroniza con todo el sistema y posee una API para que los desarrolladores aprovechen los servicios que ofrece (que son muchos). Pero en cuestión de seguridad, que es lo que interesa en este punto, se puede encontrar dentro del repertorio de servicios algunas funciones que pueden ayudar; una se encarga de revisar la seguridad del sistema y envía avisos a Google en caso que alguna sea sospechosa, y la otra, se encarga de detener una app en caso de que intente dañar el equipo.
Para activar estas opciones, el usuario se debe dirigir al menú principal, elegir "Configuraciones de Google", luego aparece un menú y se debe elegir el ítem "Seguridad", finalmente se encuentran las 2 opciones de configuración que interesan: "Buscar amenazas de Seguridad" y "Mejorar detección de aplicaciones perjudiciales" que sirven para realizar un control en busca de actividades sospechosas en el equipo y enviar información de las apps maliciosas a Google (en caso de encontrarlas) para contribuir en la mejora de este software, respectivamente. De hecho, en este menú hay otra opción que puede ayudar a mantener la privacidad de los datos del usuario, se puede activar las opciones de "Bloquear y borrar datos del dispositivo de forma remota", con lo cual se puede realizar las siguientes operaciones de forma remota (en casos excepcionales): borrar todos los datos y bloquear la pantalla.
Otro tema a resaltar con Google Play es la descarga automática de actualizaciones [AUTOUPD]. Por lo general, esta opción de configuración viene activada por defecto, al menos en el caso del smartphone que se toma como referencia. En el caso de que no esté activa la opción, se debe realizar lo siguiente: dentro de la app de Google Play ir al menú general, ir a "Configuración", y finalmente elegir "Actualizar aplicaciones automáticamente" en donde aparecerán 3 opciones: no actualizar aplicaciones automáticamente, actualizar aplicaciones automáticamente solo por wifi o por una conexión a la red de datos del proveedor del celular (puede tener recargos). Para algunos usuarios puede resultar molesto que las actualizaciones se inicien automáticamente (y sorpresivamente) cuando éstas consumen un ancho de banda considerable, para ellos puede resultarle útil la opción de ser notificados solamente cuando surgen nuevas actualizaciones.

3.3.5 Administrador de Dispositivos de Android

En Android se puede usar otro complemento que forma parte de los productos de Google, llamado Administrador de Dispositivos de Android ("Android Device Manager"), un servicio integrado al sistema operativo. Permite localizar, bloquear o eliminar datos del smartphone de forma remota desde una computadora. No se debe instalar nada en el smartphone, solo se necesita una cuenta de Google. Con este servicio activado, si un smartphone es robado o perdido, el dueño podría encontrarlo y recuperarlo. Incluso si no se pudiera recuperar el smartphone, se pueden proteger los datos sensibles realizando un borrado de ellos de forma remota.
Este servicio permite tener control del smartphone desde una computadora (un enlace remoto) de la siguiente forma: el usuario ingresa a la cuenta Google asociada a su smartphone y se dirige al panel de control [PANLADM], en donde se encuentran las operaciones posibles:
- Se puede ubicar el lugar geográfico dónde se encuentra el smartphone, se lo muestra en un mapa a través de Google Maps.
- Se puede hacer sonar al smartphone.
- Se puede bloquear la pantalla del smartphone. Permite definir una contraseña para bloquear al smartphone remotamente. Cuando se activa, pide el ingreso de una contraseña (y su reingreso), un mensaje y un número de teléfono que se van a mostrar en la pantalla; cuando se confirman estos datos se bloquea el smartphone con una pantalla particular de color negro. Si previamente no se definió una clave que bloquee la pantalla desde el smartphone, se puede aprovechar esta característica, de lo contrario la contraseña suministrada será ignorada.
- Se pueden borrar datos del smartphone. Esto implica: un reestablecimiento al estado de fábrica, se eliminarán las apps, las fotos, la música y las configuraciones. Luego, el administrador de smartphones Android ya no funcionará. Esta acción no se puede deshacer. Es posible que no se pueda borrar el contenido de la tarjeta SD del smartphone. Si el smartphone no tiene conexión, se restablecerá al estado de fábrica cuando vuelva a estar conectado.
Desde el smartphone, si se desea activar este servicio, previamente se debe activar el GPS de la siguiente forma: ir al menú principal, donde se debe elegir "Configurar", luego del menú que aparece se debe seleccionar "Ubicación" en donde se puede pulsar una llave que activa esta característica del hardware. Luego, para activar el Administrador de Dispositivos de Android [ANDMOFF], se debe seguir el siguiente camino dentro de los menúes del smartphone: dentro del menú principal, elegir "Configución de Google", luego seleccionar "Seguridad", activar la llave en donde dice "Ubicar este dispositivo de forma remota" y también "Bloquear y borrar datos del dispositivo".

3.3.6 Seguridad en la red

3.3.6.1 Conexión de las Apps

Android proporciona comunicaciones seguras a través de Internet para la navegación web, correo electrónico, mensajería instantánea y otras aplicaciones de Internet, basándose en los protocolos criptográficos como TLS (Transport Layer Security) y SSL (Secure Sockets Layer), incluyendo TLS v1.0, TLS v1.1, TLS v1.2 y SSL v3 [GOOUSER]. Éstos son los protocolos que usualmente se utilizan cuando se necesita encriptación en los datos que transitan de un host a otro. Por ejemplo, en los entornos de escritorio, todos los navegadores importantes soportan TLS [TLSWIKI].

3.3.6.2 Conexión WiFi

Android soporta conexiones inalámbricas encriptadas que respetan el protocolo WPA2-Enterprise (802.11i), el cual esta diseñado específicamente para redes empresariales. El soporte del protocolo WPA2-Enterprise usa encriptación AES-128, proporcionando a las empresas y a sus empleados un alto nivel de protección al enviar y recibir datos a través de la conexión Wi-Fi. Android soporta 802.1x EAPs (Extensible Authentication Protocols), incluyendo EAP-TLS, EAP-TTLS, PEAPv0, PEAPv1 y EAP-SIM  [GOOUSER].

3.3.6.3 Conexión con una VPN

Android soporta conexiones seguras con el uso de una VPN. La idea de una red VPN es conectarse a una red privada sobre una red pública como Internet, utilizando técnicas como tunneling y/o encriptación. Una VPN se podría establecer entre dos sistemas finales o entre dos organizaciones, entre varios sistemas finales dentro de una sola organización o entre varias organizaciones a través de Internet, entre aplicaciones individuales, o cualquier combinación de éstos. O sea, lo interesante de usar una VPN en las organizaciones es que una parte de las comunicaciones se vuelve "invisible" a los observadores ajenos a una organización, aprovechando al mismo tiempo la eficiencia de una infraestructura de comunicaciones común. Se suele usar una VPN por cuestiones económicas [CISCVPN].
Para configurar una conexión a una red VPN se debe ingresar al menú general de apps, elegir el ítem "Configurar", dentro del grupo denominado "Conexiones inalámbricas y redes" sleccionar "más", cuando aparece su submenú se debe elegir VPN. En esta sección aparecen las operaciones relacionadas con la gestión de VPNs (alta, baja, edición y conectar) [VPNANDR].

3.3.6.4 Conexión con un Proxy

El usuario tiene la posibilidad de conectarse a un servidor proxy. Un servidor proxy es una computadora que actúa como intermediario entre una red local (por ejemplo, todas las computadoras de una empresa) y una red de gran escala como Internet. Generalmente, los servidores proxy proveen un incremento en el rendimiento y en la seguridad. En algunos casos, monitorean el uso de la red externa [PROXYIU].
Un servidor proxy funciona interceptando conexiones entre el emisor y receptor. Todos los datos que entran, ingresan por un puerto y se reenvían al resto de la red a través de otro puerto. Al bloquear el acceso directo entre dos redes, los servidores proxy hacen que sea mucho más difícil para los hackers la obtención de direcciones internas y los detalles de una red privada.
Para poder configurar un proxy, el usuario debe seguir estos pasos: dentro del menú general, elegir "Configurar", luego aparece un menú del cual se debe seleccionar el ítem "Wi-FI", mantener apretado en una de las redes Wi-Fi que se listan para que aparezca un menú emergente; una vez allí, seleccionar "Modificar red", finalmente marcar el casillero "opciones avanzadas" para que se pueda ver la opción correspondiente al tipo de conexión proxy [PROXAND].

3.3.7 Multiusuario

En Android pueden haber varios perfiles de usuario (en Android, se llaman simplemente "usuarios"), tienen una configuración general propia, cada perfil guarda datos diferentes de las apps que instaló. En el uso del dispositivo, se puede usar uno de estos perfiles y la idea es que se puedan intercambiar explícitamente con un control de fácil acceso (que aparece en la parte superior de la pantalla). Una vez accedido a un perfil cualquiera, aparecerá la pantalla bloqueada (en caso de que se haya activado esta medida de seguridad). Para resumir, las características que provee esta funcionalidad son:
	- Un perfil de usuario puede correr en segundo plano cuando otro esta activo.
	- Los datos de un usuario estan siempre aislados de los otros usuarios.
Por último, Android tiene otra característica que puede ayudar a mejorar la seguridad y organizar los contenidos que generan los usuarios del dispositivo. Android implementa el concepto de usuario primario y usuario secundario [GOOUSER]:
	- Un usuario primario es el primer usuario agregado a un dispositivo. No se puede eliminar, excepto cuando se lleva al dispositivo al estado de fábrica. Este usuario también tiene privilegios especiales y configuraciones que son establecidas solamente por él. El usuario primario siempre se está ejecutando, incluso cuando otros están corriendo en primer plano.
	- Un usuario secundario puede ser cualquier usuario agregado al dispositivo, pero que no sea el usuario principal. Un usuario secundario puede ser eliminado por él mismo y por el usuario principal, pero no puede afectar a los otros usuarios de un dispositivo. Los usuarios secundarios pueden ejecutarse en segundo plano y seguir teniendo la conexión a red cuando se conectan, por ejemplo. Sin embargo, hay algunas restricciones en el acceso a los recursos; por ejemplo, cuando están corriendo en segundo plano no son capaces de mostrar la interfase del usuario o conectarse por Bluetooth. Los usuarios secundarios que corren en segundo plano son parados por el proceso del sistema, si el dispositivo requiere memoria adicional para las operaciones que esté realizando el usuario que esta corriendo en primer plano.

3.3.8 Encriptación del dispositivo

En Android se puede realizar una encriptación de disco completa (full disk encryption) [ENCRCEN], lo que quiere decir que todos los datos del usuario se pueden encriptar usando una clave de encriptación basada en el código de acceso o contraseña proporcionado para bloquear la pantalla, luego esta contraseña/clave se la pedirá cada vez que el dispositivo es encendido.
Cuando el dispositivo está encriptado, todos los datos del usuario que se vayan a crear, se cifran de forma automática antes de guardarse en el disco; asi mismo, en todas las lecturas futuras, se descifrarán los datos automáticamente antes de retornarle el poder al proceso que pidió la lectura. Este mecanismo puede servir como una protección adicional en caso de que el dispositivo se haya robado o perdido (y accedido por usuarios maliciosos). Además de ser recomendable para resguardar la seguridad, este mecanismo sirve para comprobar la integridad de los datos. Por otro lado, este mecanismo no tiene ningún efecto apreciable en el rendimiento, al menos esto sucede en los equipos más modernos.
En cuanto a la implementación del mecanismo, básicamente se puede mencionar que el algoritmo de encriptación es AES-128 [ANDENCR]. La llave maestra también es encriptada con AES-128 mediante llamadas a la librería OpenSSL adaptada al entorno Android, aunque los fabricantes del dispositivo pueden usar AES de 128 bits o más. El proyecto original de Android (AOSP) maneja la encriptación, por lo general, desde el almacenamiento interno, no así en el contenido de la tarjeta SD; aunque algunos fabricantes agregan una función de encriptación de la tarjeta SD, modificando el sistema operativo.
Previo a la realización de la encriptación [ENCDATA] se debe considerar estos 4 puntos: establecer una clave de bloqueo de pantalla (como previamente se describió), conectar el cargador al dispositivo, tener en cuenta que el proceso inicial llevará un tiempo (una hora o más) y finalmente, se debe considerar que si se interrumpe el proceso de encriptación se pueden perder datos (para disminuir las pérdidas se puede realizar un backup). Si no cumple alguna de las 2 primeras condiciones (si se está sin clave y sin cargador conectado), el sistema deniega el acceso al comando de encriptación.
Para proceder con la encriptación, el usuario se debe dirigir al menú principal, de ahí elegir el ítem "Configurar", dentro de sus opciones seleccionar "Seguridad"; finalmente, en esta instancia se debe seleccionar "Encriptar teléfono".
Luego de la encriptación, la clave se exigirá cada vez que se arranque el sistema. Ésto sirve para comprobar la integridad de los archivos. Se puede deshabilitar esta característica, pero no es recomendable.

[ OPCIONAL ]
Verificación de 2 pasos
-----------------------

Esta medida de seguridad forma parte del grupo de servicios de Google. Muchas de las apps que vienen preinstaladas en los smartphones con Android pertenecen a Google y para poder utilizarlas, se exige el ingreso de los datos de una cuenta de Google, de lo contrario no se va a poder utilizar la app. Este mecanismo de las cuentas de Google, se llama "Verificación en 2 pasos" y sirve para proteger la cuenta Google que esté relacionada al dispositivo [GOO2STEP].

Ideas principales [GOO2STEP]:
- La verificación en dos pasos te protegerá de usuarios malintencionados incluso en el caso de que tengan tu contraseña.
- La mayoría de los usuarios solo tienen una capa de seguridad, su contraseña, para proteger su cuenta. Con la verificación en dos pasos, si un hacker consigue franquear la capa de seguridad de tu contraseña, todavía necesitará tu teléfono o tu llave de seguridad para acceder a tu cuenta.

La verificación en dos pasos es uno de los mejores consejos de seguridad. Además de poner la contraseña en las apps, con este método hay que añadir un código que nos envían a través de SMS. Sin este mensaje nadie podrá entrar en nuestra cuenta, ni siquiera aunque sepa la contraseña. Es un método algo engorroso pero vital para cubrirnos de cualquier riesgo. No solo Google está introduciendo este sistema, la mayoría de grandes empresas también lo ha hecho. Para activarlo tendremos que ir a los ajustes de Google.

[GOO2STEP] [ https://www.google.es/intl/es/landing/2step/ ]
[ http://www.elandroidelibre.com/2014/12/10-sencillos-consejos-para-mejorar-la-seguridad-de-tu-android.html ]

[ OPCIONAL ]
Seguridad de las aplicaciones [externa al SO]
---------------------------------------------
---------------------------------------------

Las restricciones para preservar la seguridad en Android se manifiestan de diferentes formas. En algunos casos, cuando se trata con ciertas funciones delicadas del sistema, existe cierta restricción intencionada en el acceso con la omisión de APIs (por ejemplo no hay una API para Android para manipular directamente la tarjeta SIM). Por otro lado, como ya se mencionó, existe la separación de roles con respecto a los recursos (generalmente archivos) que provee una medida de seguridad, por ejemplo cuando se distinguen a los usuarios que acceden a un archivo (se lo puede identificar como dueño, miembro de un grupo o cualquier otro usuario), ésta es una característica heredada de Linux. En otros casos, ciertas APIs protegidas pueden ser usadas por aplicaciones confiables, emplean un mecanismo de seguridad conocido como permiso; estas APIs poseen limitaciones que se pueden alterar explícitamente con la finalidad de proteger servicios valiosos del dispositivo como las funciones de la cámara, los datos de la ubicación (GPS), funciones de Bluetooth, funciones de telefonía, funciones relacionadas a la mensajería del tipo SMS/MMS y las conexiones de datos o redes.

[Fuente: http://source.android.com/tech/security/index.html]

[ OPCIONAL ]
Gogle Play
-----------

Fuente:
https://en.wikipedia.org/wiki/Google_Play#Application_security

[ OPCIONAL ]
Fragmentación
-------------

A la fecha de hoy, 6 de Diciembre del 2012, Android es la plataforma móvil más popular: tiene una gran comunidad de desarrolladores programando aplicaciones con el fin de extender la funcionalidad de los dispositivos que soportan Android. Los desarrolladores pueden usar Google Play como medio de propagación para difundir sus aplicaciones, este repositorio alberga a más de 600000 aplicaciones. Según el libro titulado "Forense en Android", Google Play se lo puede comparar con la propuesta similar de Apple llamada App Store, salvo que esta última se distingue por su control estricto en el proceso de revisión de aplicaciones al momento de publicar una aplicación; no sucede así con Google Play, que tiene requisitos mas ligeros, aunque tiene la capacidad para inhabilitar a los desarrolladores que lleguen a publicar sofware malicioso y eliminar sus aplicaciones. [ANDACT]

El siguiente cuadro se basa en la cantidad de accesos de dispositivos Android a Google Play según la versión, en un período de 14 días (del 20 de Noviembre al 3 de Diciembre del 2012 inclusive). [DASHBO]

Version			Nombre en código	Versión de la API		Distribución
1.5				Cupcake				3						0.1%
1.6				Donut				4						0.3%
2.1				Eclair				7						2.7%
2.2				Froyo				8						10.3%
2.3 - 2.3.2		Gingerbread			9						0.2%
2.3.3 - 2.3.7						10						50.6%
3.1				Honeycomb			12						0.4%
3.2									13						1.2%
4.0.3 - 4.0.4	Ice Cream Sandwich	15						27.5%
4.1				Jelly Bean			16						5.9%
4.2									17						0.8%

[DASHBO] [Fuente: http://developer.android.com/about/dashboards/index.html]
[ANDACT] [Fuente: http://es.wikipedia.org/wiki/Android] (sección "Historial de actualizaciones")

[OPCIONAL]
Mejoras en la administración de la memoria (hecho el 19/02/2013)

ASLR (address space layout randomization) es un mecanismo de seguridad informático que consiste en la disposición aleatoria de las direcciones de las áreas claves de datos como la base del ejecutable, la dirección de las bibliotecas, la heap y el stack, que están dentro del espacio de direcciones de un proceso. De esta forma, este mecanismo obstruye algunos tipos de ataques de seguridad haciendo mas difícil la predicción de las direcciones destino para un atacante.
La efectividad esta basada en la baja posibilidad de un atacante en adivinar las ubicaciones de las áreas aleatoriamente colocadas. A medida que se aumenta el espacio de búsqueda (aumentando el área de memoria virtual), se incrementa la seguridad. También se puede reducir el período durante el cual se produce la aleatorización para mejorar la efectividad, aunque generalmente este período se reduce lo máximo posible, entonces la mayoría de los sistemas deben optar por la primer opción.
El proyecto PaX fue el primero en emplear el término "ASLR", publicó el primer diseño e implementación de ASLR en julio del 2001, como un patch para Linux que es muy popular. Este proyecto sigue siendo la aplicación más completa, que en octubre del 2002 también proporcionó la asignación al azar en la pila del núcleo. OpenBSD se volvió en el primer sistema operativo de primera línea en proveer un soporte parcial de ASLR y terminó de incorporarlo en el año 2008. A partir de la versión 4.0 (conocida como "Ice Cream Sandwich"), Android introdujo ASLR para ayudar a proteger al sistema y a las aplicaciones de terceros de los exploits que aprovechan las imperfecciones en la administración de memoria; Apple lo introdujo en la versión 4.3 de iOS.

[Fuente: http://en.wikipedia.org/wiki/Address_space_layout_randomization#Android]
[Fuente: http://source.android.com/tech/security/index.html]

PIC (position-independent code) es una porción de código máquina que si se ubica en algún lugar de la memoria primaria se ejecuta correctamente independientemente de su dirección absoluta. PIC es comunmente usada para las bibliotecas compartidas, de modo que el mismo código de la biblioteca puede ser cargado en una ubicación en cada espacio de direcciones de programa en el que no se superponen otros usos de la memoria (por ejemplo, otras bibliotecas compartidas). PIE (Position-independent executables) tiene sus bases en PIC, pero en este caso, los fragmentos de código son binarios ejecutables que son completamente independientes del código. Los binarios PIE son usados en algunas distribuciones Linux enfocadas en la seguridad, que permite la asignación aleatoria de direcciones de memoria para evitar que los atacantes averigüen donde está el código ejecutable usando exploits que se basan en conocer el desplazamiento del código ejecutable en el binario.
En Android fue incorporado a partir de la versión 4.1.

[Fuente: http://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables]
[Fuente: http://source.android.com/tech/security/index.html]

El bit NX (deriva de "Never eXecute") es una tecnología empleada por las CPUs que separa áreas de memoria para que sean usadas para almacenar código o datos de forma exclusiva. Un sistema operativo con soporte para el bit NX puede marcar ciertas áreas de memoria como "no ejecutable". Entonces, el procesador denegará la ejecución de cualquier código que resida en estas áreas de memoria. La técnica general, conocida como "protección de espacio ejecutable", es usada para evitar que ciertos tipos de programas maliciosos tomen el control del sistema insertando su código dentro de otra área de datos del programa y corriendo su propio código desde adentro de esta sección; esto es conocido como un ataque "buffer overflow". Por ejemplo, Intel implanta esta característica como el bit XD (deriva de "eXecute Disable"), AMD usa el nombre de Enhanced Virus Protectiony, la arquitectura ARM hace referencia a esta propiedad como XN (eXecute Never) que fue introducida en ARM v6. A partir de la versión 2.3 de Android y posteriores, el hardware que lo soporta tiene páginas no ejecutables por defecto, evitando la ejecución del stack y la heap.

[Fuente: http://en.wikipedia.org/wiki/NX_bit]
